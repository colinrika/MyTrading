<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>üöÄ Namu Trading</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #0d1117;
      color: #e6edf3;
      text-align: center;
      margin: 0;
      padding: 20px;
    }

    h2 {
      color: #58a6ff;
      margin: 8px 0 10px 0;
    }

    .topBar {
      width: 92%;
      max-width: 1100px;
      margin: 0 auto 12px auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .pill {
      background: #161b22;
      border: 2px solid #30363d;
      padding: 10px 12px;
      border-radius: 10px;
      color: #e6edf3;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    a.linkBtn,
    button.linkBtn {
      text-decoration: none;
      background: #58a6ff;
      color: #fff;
      font-weight: bold;
      border-radius: 10px;
      padding: 10px 14px;
      display: inline-block;
      border: none;
      cursor: pointer;
    }

    a.linkBtn:hover,
    button.linkBtn:hover {
      filter: brightness(1.05);
    }

    #alertBox {
      background-color: #161b22;
      border: 2px solid #30363d;
      padding: 15px;
      border-radius: 10px;
      width: 92%;
      max-width: 1100px;
      margin: 0 auto 14px auto;
      text-align: left;
    }

    #safePanel {
      width: 92%;
      max-width: 1100px;
      margin: 12px auto;
      padding: 12px;
      background: #161b22;
      border: 2px solid #30363d;
      border-radius: 10px;
      text-align: left;
    }

    #safePanel h3 {
      margin: 0 0 10px 0;
    }

    .muted {
      color: #8b949e;
      font-size: 12px;
    }

    .safeTrade {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #0d1117;
      border-radius: 8px;
      padding: 10px 14px;
      margin: 8px 0;
      cursor: pointer;
      transition: 0.3s;
      gap: 12px;
    }

    .safeTrade:hover {
      background: #1f6feb33;
    }

    .safeBadge {
      font-size: 12px;
      font-weight: bold;
      border-radius: 6px;
      padding: 4px 8px;
      background: #00c85333;
      color: lightgreen;
      white-space: nowrap;
    }

    .safeTag {
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #30363d;
      background: #0d1117;
      color: #e6edf3;
      white-space: nowrap;
    }

    table {
      width: 92%;
      max-width: 1100px;
      margin: 16px auto;
      border-collapse: collapse;
    }

    th,
    td {
      padding: 10px;
      border: 1px solid #30363d;
      cursor: pointer;
    }

    th {
      background-color: #161b22;
    }

    tr:hover {
      background-color: #1f6feb44;
    }

    .strongBuy {
      color: lightgreen;
      font-weight: bold;
    }

    .neutral {
      color: #ffcc00;
    }

    .highlightRow {
      box-shadow: 0 0 12px 2px rgba(0, 255, 0, 0.3);
      animation: pulse 1.8s infinite alternate;
    }

    @keyframes pulse {
      from {
        box-shadow: 0 0 6px rgba(0, 255, 0, 0.1);
      }

      to {
        box-shadow: 0 0 14px rgba(0, 255, 0, 0.5);
      }
    }

    footer {
      margin-top: 20px;
      color: #8b949e;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 10;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      overflow-y: auto;
    }

    .modal-content {
      background: #161b22;
      margin: 3% auto;
      padding: 18px;
      border: 2px solid #30363d;
      border-radius: 10px;
      width: 92%;
      max-width: 1100px;
      color: #e6edf3;
      text-align: left;
      max-height: 92vh;
      overflow-y: auto;
    }

    .close {
      float: right;
      color: #aaa;
      font-size: 22px;
      cursor: pointer;
    }

    .close:hover {
      color: #fff;
    }

    canvas {
      width: 100%;
      height: 460px !important;
      margin-top: 10px;
    }

    .profitBox {
      border: 1px solid #30363d;
      background-color: #0d1117;
      border-radius: 10px;
      padding: 12px;
      margin-top: 12px;
    }

    .rowFlex {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .rowFlex>div {
      flex: 1 1 260px;
    }

    input,
    select {
      border-radius: 6px;
      border: 1px solid #30363d;
      background: #0d1117;
      color: #e6edf3;
      padding: 6px 8px;
      width: 100%;
      box-sizing: border-box;
    }

    button.primaryBtn {
      width: 100%;
      border: none;
      border-radius: 10px;
      padding: 14px 16px;
      font-weight: bold;
      cursor: pointer;
      background: #58a6ff;
      color: #fff;
      margin-top: 10px;
      font-size: 16px;
    }

    button.primaryBtn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .strategyTag {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #30363d;
      background: #0d1117;
      color: #e6edf3;
      font-size: 12px;
      margin-left: 8px;
      vertical-align: middle;
    }

    .good {
      color: lightgreen;
    }

    .warn {
      color: #ffcc00;
    }

    .bad {
      color: #ff5555;
    }
  </style>
</head>

<body>
  <h2>üöÄ Namu Trading Dashboard</h2>

  <div class="topBar">
    <div class="pill">
      <span class="warn">Live trading</span>
      <span class="muted" id="usdQuick">USD loading</span>
      <span class="muted" id="modeBadge"></span>
      <span class="muted" id="authBadge"></span>
    </div>

    <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
      <label class="pill" style="cursor:pointer;">
        <input id="aggressiveToggle" type="checkbox" style="width:auto; margin:0 8px 0 0;">
        <span style="font-weight:bold;">Aggressive Mode</span>
        <span class="muted" id="aggressiveBadge">Off</span>
      </label>

      <a id="connectKrakenBtn" class="linkBtn" href="/connect-kraken.html">üîë Connect Kraken</a>
      <a class="linkBtn" href="/account.html">üìí Trades</a>
      <button class="linkBtn" id="logoutBtn">üö™ Logout</button>
    </div>
  </div>

  <div id="safePanel">
    <h3>üõ°Ô∏è Safest Trades Right Now</h3>
    <div class="muted">This list only shows items your strategy would actually approve.</div>
    <div id="safeTradesList">Loading...</div>
  </div>

  <div id="alertBox">Fetching market data...</div>

  <table id="results">
    <thead>
      <tr>
        <th>Coin</th>
        <th>Price</th>
        <th>Forecast Change</th>
        <th>RSI</th>
        <th>Score</th>
        <th>Signal</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div id="strategyModal" class="modal">
    <div class="modal-content">
      <span class="close" id="modalCloseBtn">&times;</span>
      <h3 id="modalTitle"></h3>
      <canvas id="projectionChart"></canvas>
      <div id="modalContent"></div>
    </div>
  </div>

  <footer>üìä Created by Colin Rika</footer>

  <script>
    const AUTO_TRADING_ALWAYS_ON = false;

    const MAX_SCAN_PAIRS = 60;
    const OHLC_INTERVAL_MIN = 60;
    const OHLC_CANDLES = 60;
    const RSI_PERIOD = 14;

    const blockedPairs = new Set(JSON.parse(localStorage.getItem("blockedPairs") || "[]"));

    const alertBoxEl = document.getElementById("alertBox");
    const safeListEl = document.getElementById("safeTradesList");
    const tableBodyEl = document.querySelector("#results tbody");

    const modalEl = document.getElementById("strategyModal");
    const modalTitleEl = document.getElementById("modalTitle");
    const modalContentEl = document.getElementById("modalContent");
    const modalCloseBtnEl = document.getElementById("modalCloseBtn");
    const projectionCanvasEl = document.getElementById("projectionChart");

    let SIMULATOR = false;

    let AGGRESSIVE_MODE = String(localStorage.getItem("AGGRESSIVE_MODE") || "false").toLowerCase() === "true";

    function setAggressiveUi() {
      const cb = document.getElementById("aggressiveToggle");
      const badge = document.getElementById("aggressiveBadge");
      if (cb) cb.checked = AGGRESSIVE_MODE;
      if (badge) badge.textContent = AGGRESSIVE_MODE ? "On" : "Off";
    }

    function nextTradeWindowText() {
      const now = new Date();
      const h = now.getHours();
      if (h >= 5 && h < 9) return "Trade window is open now";
      const next = new Date(now);
      if (h >= 9) next.setDate(now.getDate() + 1);
      next.setHours(5, 0, 0, 0);
      const mins = Math.max(0, Math.round((next.getTime() - now.getTime()) / 60000));
      const hrs = Math.floor(mins / 60);
      const rem = mins % 60;
      return "Trade window opens at 5 AM. Time until open " + hrs + " hours " + rem + " minutes";
    }


    let intervalIds = [];
    let loggedOut = false;
    let redirecting = false;

    function apiUrl(p) { return window.location.origin + p; }

    function startIntervals() {
      intervalIds.push(setInterval(refreshMode, 30000));
      intervalIds.push(setInterval(refreshUsdQuick, 30000));
      intervalIds.push(setInterval(analyze, 300000));
    }

    function stopIntervals() {
      for (const id of intervalIds) clearInterval(id);
      intervalIds = [];
    }

    function redirectToLoginOnce() {
      if (redirecting) return;
      redirecting = true;
      loggedOut = true;
      stopIntervals();
      window.location.replace("/login.html");
    }

    function toggleAccountAccess(loggedIn) {
      const btn = document.querySelector("a[href='/account.html']");
      if (!btn) return;
      btn.style.display = loggedIn ? "inline-block" : "none";
    }


    async function getJson(url) {
      const resp = await fetch(url, { credentials: "include" });
      const text = await resp.text();
      let data = {};
      try { data = JSON.parse(text); } catch { data = { raw: text }; }

      if (!resp.ok) {
        if (resp.status === 401) {
          redirectToLoginOnce();
          throw new Error("Unauthorized");
        }
        const err = new Error(data?.details || data?.error || ("Request failed " + resp.status));
        err.payload = data;
        throw err;
      }
      return data;
    }

    async function postJson(url, payload) {
      const resp = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        credentials: "include"
      });

      const text = await resp.text();
      let data = {};
      try { data = JSON.parse(text); } catch { data = { raw: text }; }

      if (!resp.ok) {
        if (resp.status === 401) {
          redirectToLoginOnce();
          throw new Error("Unauthorized");
        }
        const err = new Error(data?.details || data?.error || ("Request failed " + resp.status));
        err.payload = data;
        throw err;
      }
      return data;
    }

    async function ensureLoggedIn() {
      try {
        await getJson(apiUrl("/balance"));
        document.getElementById("authBadge").textContent = "Logged in";
        toggleAccountAccess(true);
      } catch {
        toggleAccountAccess(false);
        redirectToLoginOnce();
      }
    }


    function hideConnectBtn() {
      const btn = document.getElementById("connectKrakenBtn");
      if (btn) btn.style.display = "none";
    }

    function showConnectBtn() {
      const btn = document.getElementById("connectKrakenBtn");
      if (btn) btn.style.display = "inline-block";
    }

    async function checkKrakenConnectedAndToggle() {
      try {
        const s = await getJson(apiUrl("/api/account/status"));

        const raw =
          s?.krakenConnected ??
          s?.connected ??
          s?.isConnected ??
          s?.data?.krakenConnected ??
          s?.data?.connected;

        const connected = raw === true || raw === "true" || raw === 1 || raw === "1";

        if (connected) {
          hideConnectBtn();
          return;
        }
      } catch {
        // ignore and try balance fallback
      }

      // Fallback: if balance works, you are effectively connected
      try {
        const d = await getJson(apiUrl("/balance"));
        const usd = Number(d?.balance?.ZUSD);
        if (Number.isFinite(usd)) {
          hideConnectBtn();
          return;
        }
      } catch (e) {
        console.error("Analyze failed for pair", p, e);
      }


      showConnectBtn();
    }


    async function doLogout() {
      loggedOut = true;
      stopIntervals();
      try { await postJson(apiUrl("/api/logout"), {}); } catch { }
      redirectToLoginOnce();
    }

    document.getElementById("logoutBtn").addEventListener("click", doLogout);

    async function refreshMode() {
      if (loggedOut) return;
      try {
        const m = await getJson(apiUrl("/mode"));
        SIMULATOR = m && m.simulator === true;
        document.getElementById("modeBadge").textContent = SIMULATOR ? "Simulator ON" : "Simulator OFF";
      } catch {
        SIMULATOR = false;
        document.getElementById("modeBadge").textContent = "";
      }
    }

    function prettyPair(pair) { return String(pair).replace("X", "").replace("ZUSD", "/USD"); }

    function blockPair(pair) {
      blockedPairs.add(pair);
      localStorage.setItem("blockedPairs", JSON.stringify(Array.from(blockedPairs)));
    }

    function num(v) {
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    }

    async function getPairInfo(pair) {
      try {
        return await getJson(apiUrl("/pair-info?pair=" + encodeURIComponent(pair)));
      } catch {
        return { ordermin: null, costmin: null };
      }
    }

    function calcMinUsd(pairInfo, price) {
      const ordermin = num(pairInfo?.ordermin);
      const costmin = num(pairInfo?.costmin);
      const byVol = (ordermin > 0) ? (ordermin * price) : 0;
      const byCost = (costmin > 0) ? costmin : 0;
      const minUsd = Math.max(byVol, byCost);
      return (minUsd > 0) ? minUsd : 0;
    }

    function linearRegression(y, x) {
      const n = y.length;
      const sumx = x.reduce((a, b) => a + b, 0);
      const sumy = y.reduce((a, b) => a + b, 0);
      const sumxy = y.reduce((a, b, i) => a + b * x[i], 0);
      const sumxx = x.reduce((a, b) => a + b * b, 0);
      const denom = (n * sumxx - sumx * sumx);
      const m = denom === 0 ? 0 : (n * sumxy - sumx * sumy) / denom;
      const b = (sumy - m * sumx) / n;
      return { m, b };
    }

    function calculateRSI_Wilder(closes, period) {
      if (!Array.isArray(closes) || closes.length < period + 1) return 50;

      let gains = 0;
      let losses = 0;

      for (let i = 1; i <= period; i++) {
        const delta = closes[i] - closes[i - 1];
        if (delta >= 0) gains += delta;
        else losses -= delta;
      }

      let avgGain = gains / period;
      let avgLoss = losses / period;

      for (let i = period + 1; i < closes.length; i++) {
        const delta = closes[i] - closes[i - 1];
        const gain = delta > 0 ? delta : 0;
        const loss = delta < 0 ? -delta : 0;
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;
      }

      if (avgLoss === 0) return 100;
      const rs = avgGain / avgLoss;
      return 100 - (100 / (1 + rs));
    }

    function buildScore(predChange, trendSlope, rsi) {
      const bonusMidRsi = (rsi >= 50 && rsi <= 65) ? 5 : 0;
      const penaltyOverbought = (rsi > 70) ? 10 : 0;
      return (predChange * 2) + (trendSlope * 10) + bonusMidRsi - penaltyOverbought;
    }

    function isTradeWindow() {
      const now = new Date();
      const hour = now.getHours();
      return hour >= 5 && hour < 9;
    }

    function buildUserExplanation(ctx) {
      const parts = [];

      parts.push("You are viewing a " + (isTradeWindow() ? "valid trading time window" : "non trading time window") + ". " + nextTradeWindowText() + ".");

      parts.push("Momentum estimate is " + Number(ctx.pred).toFixed(2) + " percent over the next few hours based on your simple trend forecast.");
      parts.push("RSI is " + Number(ctx.rsi).toFixed(1) + ". Around 50 is neutral. Below 30 is oversold. Above 70 is overbought.");

      if (ctx.uptrend) parts.push("Trend slope is positive, meaning price has been rising recently.");
      if (ctx.downtrend) parts.push("Trend slope is negative, meaning price has been falling recently.");

      if (ctx.rsiRising) parts.push("RSI has been improving recently, which can signal buyers returning.");
      else parts.push("RSI is not clearly improving yet, so rebounds are less reliable.");

      if (ctx.priceUp) parts.push("Price is currently pushing higher versus earlier candles.");
      else parts.push("Price is not pushing higher yet, so breakouts are not confirmed.");

      return parts.join(" ");
    }

    function buildNextSteps(ctx) {
      const tips = [];

      if (!isTradeWindow()) {
        tips.push("Wait for the trade window 5 AM to 9 AM California time.");
        return tips.join(" ");
      }

      if (ctx.pred < 3) tips.push("Forecast is weak. Wait for forecast change to reach 3 percent or more.");
      if (ctx.downtrend) tips.push("Trend is still down. Wait for trend slope to turn positive or flatten out.");
      if (!ctx.priceUp) tips.push("No breakout yet. Wait for price to start making higher closes.");
      if (!ctx.rsiRising) tips.push("RSI is not improving. Wait for RSI to start rising for at least a few candles.");

      if (ctx.rsi > 70) tips.push("RSI is high. If you buy here, you risk buying the top. Prefer waiting for a pullback or a confirmed breakout.");
      if (ctx.rsi < 30) tips.push("RSI is oversold. A rebound is possible, but wait for RSI to turn upward to reduce false entries.");

      if (!tips.length) tips.push("Conditions are close. Wait for one more candle confirmation.");

      return tips.join(" ");
    }



    function decideStrategyOrder(res, currentPrice, aggressive) {
      const rsi = Number(res.rsi);
      const pred = Number(res.predChange);
      const slope = Number(res.slope || 0);

      const rsiSeries = Array.isArray(res.rsiHist) ? res.rsiHist : [];
      const rsiNow = rsiSeries.length ? rsiSeries[rsiSeries.length - 1] : rsi;
      const rsiPrev = rsiSeries.length >= 4 ? rsiSeries[rsiSeries.length - 4] : rsiNow;
      const rsiRising = (rsiNow - rsiPrev) > 2.0;

      const priceSeries = Array.isArray(res.prices) ? res.prices : [];
      const priceNow = priceSeries.length ? priceSeries[priceSeries.length - 1] : currentPrice;
      const pricePrev = priceSeries.length >= 4 ? priceSeries[priceSeries.length - 4] : priceNow;
      const priceUp = priceNow > pricePrev;

      const strongForecast = pred >= 5;
      const decentForecast = pred >= 3;

      const uptrend = slope > 0;
      const downtrend = slope < 0;

      const ctx = { rsi, pred, slope, uptrend, downtrend, rsiRising, priceUp };

      const why = buildUserExplanation(ctx);
      const nextSteps = buildNextSteps(ctx);

      if (!isTradeWindow()) {
        return {
          tag: "Outside trade window",
          actionTitle: "High potential but not safe timing",
          details:
            "This coin shows strong upside potential, but your strategy only trades between 5 AM and 9 AM California time. " +
            "Outside this window, false breakouts and low liquidity are more common. " + why,
          side: null,
          orderType: null,
          price: null,
          quality: 0,
          explain: why,
          next: nextSteps
        };
      }

      if (rsi > 72 && pred < 0) {
        return {
          tag: "Overbought exit",
          actionTitle: "Sell to protect gains",
          details:
            "RSI is very high and the forecast has turned negative. This often signals momentum exhaustion. " + why,
          side: "sell",
          orderType: "limit",
          price: currentPrice,
          quality: 70,
          explain: why,
          next: nextSteps
        };
      }

      if (rsi <= 28 && strongForecast && rsiRising) {
        return {
          tag: "Oversold entry",
          actionTitle: "Buy after weakness",
          details:
            "RSI is deeply oversold, the forecast is strong, and RSI has started turning upward. This is a rebound setup with defined risk. " +
            why,
          side: "buy",
          orderType: "limit",
          price: currentPrice,
          quality: 80,
          explain: why,
          next: nextSteps
        };
      }

      if (rsi >= 44 && rsi <= 58 && strongForecast && uptrend && priceUp) {
        const trigger = currentPrice * 1.01;
        const limit = trigger * 1.003;
        return {
          tag: "Momentum breakout",
          actionTitle: "Buy on breakout confirmation",
          details:
            "Trend is already up, forecast is strong, and price is starting to push higher. The strategy waits for a small breakout confirmation before entering. " +
            why,
          side: "buy",
          orderType: "stop-loss-limit",
          price: trigger,
          price2: limit,
          quality: 90,
          explain: why,
          next: nextSteps
        };
      }

      if (rsi <= 35 && decentForecast && rsiRising && !downtrend) {
        return {
          tag: "Cautious rebound",
          actionTitle: "Buy only if rebound forms",
          details:
            "RSI is low and improving, the forecast is decent, and the trend is not sharply down. This is a lower confidence rebound setup. " +
            why,
          side: "buy",
          orderType: "limit",
          price: currentPrice,
          quality: 65,
          explain: why,
          next: nextSteps
        };
      }

      if (aggressive === true) {
        const aggressiveOk = pred >= 3 && uptrend && rsi >= 58 && rsi <= 68;
        if (aggressiveOk) {
          return {
            tag: "Aggressive continuation",
            actionTitle: "Buy strong momentum",
            details:
              "Aggressive Mode is enabled. This buys into a strong trend even when RSI is elevated. Higher upside potential, but higher risk of buying the top. " +
              why,
            side: "buy",
            orderType: "limit",
            price: currentPrice,
            quality: 60,
            explain: why,
            next: nextSteps
          };
        }
      }

      return {
        tag: "No setup",
        actionTitle: "No trade right now",
        details:
          "The coin may look bullish, but conditions do not align for a safe entry according to your strategy. " + why,
        side: null,
        orderType: null,
        price: null,
        quality: 0,
        explain: why,
        next: nextSteps
      };
    }



    function openModal() { modalEl.style.display = "block"; }
    function closeModal() { modalEl.style.display = "none"; }
    modalCloseBtnEl.addEventListener("click", closeModal);
    window.addEventListener("click", (e) => { if (e.target === modalEl) closeModal(); });

    async function refreshUsdQuick() {
      if (loggedOut) return;
      try {
        const d = await getJson(apiUrl("/balance"));
        const usd = Number(d.balance?.ZUSD || 0);
        document.getElementById("usdQuick").textContent = "USD " + usd.toFixed(4) + " updated " + new Date().toLocaleTimeString();
      } catch {
        document.getElementById("usdQuick").textContent = "USD unavailable";
      }
    }

    async function getAllUsdPairs() {
      const r = await fetch("https://api.kraken.com/0/public/AssetPairs");
      const j = await r.json();
      const result = j.result || {};
      const pairs = [];

      for (const key of Object.keys(result)) {
        const info = result[key];
        const wsname = info?.wsname || "";
        if (!wsname.endsWith("/USD")) continue;
        if (String(key).includes(".")) continue;
        pairs.push(key);
      }
      return pairs;
    }

    async function fetchTickerBatch(pairsChunk) {
      const url = "https://api.kraken.com/0/public/Ticker?pair=" + encodeURIComponent(pairsChunk.join(","));
      const r = await fetch(url);
      const j = await r.json();
      return j.result || {};
    }

    async function getTopPairsByVolumeUsd(allPairs, topN) {
      const pairs = allPairs.slice();
      const batchSize = 20;
      const scores = [];

      for (let i = 0; i < pairs.length; i += batchSize) {
        const chunk = pairs.slice(i, i + batchSize);
        let tick = {};
        try { tick = await fetchTickerBatch(chunk); } catch { tick = {}; }

        for (const pairKey of chunk) {
          const t = tick[pairKey];
          if (!t) continue;

          const last = Number(t.c && t.c[0]) || 0;
          const vol24 = Number(t.v && t.v[1]) || 0;
          const volUsd = last * vol24;

          if (volUsd > 0) scores.push({ pair: pairKey, volUsd });
        }
      }

      scores.sort((a, b) => b.volUsd - a.volUsd);
      return scores.slice(0, topN).map(x => x.pair);
    }

    async function fetchOHLC(pair) {
      const r = await fetch("https://api.kraken.com/0/public/OHLC?pair=" + encodeURIComponent(pair) + "&interval=" + OHLC_INTERVAL_MIN);
      const j = await r.json();
      const k = Object.keys(j.result || {}).find(x => x !== "last");
      if (!k || !Array.isArray(j.result[k])) return [];

      return j.result[k].slice(-OHLC_CANDLES).map(x => ({
        time: new Date(x[0] * 1000).toLocaleTimeString([], { hour: "numeric" }),
        close: Number(x[4])
      }));
    }

    function buildModalChart(res) {
      const src = (res.chartData && res.chartData.length) ? res.chartData : res.data;
      const prices = src.map(d => d.close);
      const times = src.map(d => d.time);

      const x = prices.map((_, i) => i + 1);
      const lrP = linearRegression(prices, x);
      const forecast = Array.from({ length: 5 }, (_, i) => lrP.m * (x.length + i + 1) + lrP.b);

      const rsiHist = [];
      for (let i = 0; i < prices.length; i++) rsiHist.push(calculateRSI_Wilder(prices.slice(0, i + 1), RSI_PERIOD));

      const rsiX = rsiHist.map((_, i) => i + 1);
      const lrR = linearRegression(rsiHist, rsiX);
      const rsiForecast = Array.from({ length: 5 }, (_, i) => lrR.m * (rsiHist.length + i + 1) + lrR.b);

      const entry = res.last;
      const tp = entry * 1.05;
      const sl = entry * 0.93;

      const labels = times.concat(["+1h", "+2h", "+3h", "+4h", "+5h"]);
      const forecastSeries = Array(prices.length).fill(null).concat(forecast);
      const rsiHistSeries = rsiHist.concat(Array(5).fill(null));
      const rsiForecastSeries = Array(prices.length).fill(null).concat(rsiForecast);

      if (window.projChart) window.projChart.destroy();

      window.projChart = new Chart(projectionCanvasEl, {
        type: "line",
        data: {
          labels,
          datasets: [
            { label: "Price", data: prices.concat(Array(5).fill(null)), borderColor: "#4da3ff", borderWidth: 4, tension: 0.35, pointRadius: 0, yAxisID: "y" },
            { label: "Forecast", data: forecastSeries, borderColor: "rgba(77,163,255,0.70)", borderWidth: 3, borderDash: [8, 7], tension: 0.35, pointRadius: 0, yAxisID: "y" },

            { label: "RSI", data: rsiHistSeries, borderColor: "#b36bff", borderWidth: 4, tension: 0.25, pointRadius: 0, yAxisID: "y1" },
            { label: "RSI Forecast", data: rsiForecastSeries, borderColor: "rgba(179,107,255,0.55)", borderWidth: 3, borderDash: [6, 8], tension: 0.25, pointRadius: 0, yAxisID: "y1" },

            { label: "Take Profit", data: Array(labels.length).fill(tp), borderColor: "rgba(0,255,0,0.85)", borderWidth: 3, borderDash: [12, 9], pointRadius: 0, yAxisID: "y" },
            { label: "Stop Loss", data: Array(labels.length).fill(sl), borderColor: "rgba(255,80,80,0.75)", borderWidth: 3, borderDash: [12, 9], pointRadius: 0, yAxisID: "y" }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          devicePixelRatio: 2,
          interaction: { mode: "index", intersect: false },
          plugins: {
            legend: {
              position: "bottom",
              labels: {
                color: "#ffffff",
                padding: 18,
                boxWidth: 18,
                font: { size: 16, weight: "bold" },
                usePointStyle: true,
                pointStyle: "line"
              }
            },
            tooltip: {
              enabled: true,
              backgroundColor: "rgba(0,0,0,0.92)",
              titleColor: "#fff",
              bodyColor: "#fff",
              borderColor: "rgba(255,255,255,0.18)",
              borderWidth: 1,
              titleFont: { size: 15, weight: "bold" },
              bodyFont: { size: 14 },
              padding: 12
            }
          },
          scales: {
            x: {
              ticks: {
                color: "#ffffff",
                font: { size: 14, weight: "bold" },
                maxRotation: 0,
                autoSkip: false,
                callback: function (value, index) {
                  const step = Math.ceil(labels.length / 7);
                  return (index % step === 0) ? labels[index] : "";
                }
              },
              grid: { color: "rgba(255,255,255,0.08)" }
            },
            y: {
              title: { display: true, text: "Price", color: "#4da3ff", font: { size: 16, weight: "bold" } },
              ticks: { color: "#4da3ff", font: { size: 13, weight: "bold" }, callback: v => Number(v).toFixed(6) },
              grid: { color: "rgba(77,163,255,0.10)" }
            },
            y1: {
              position: "right",
              min: 20,
              max: 80,
              title: { display: true, text: "RSI", color: "#b36bff", font: { size: 16, weight: "bold" } },
              ticks: { color: "#b36bff", stepSize: 10, font: { size: 13, weight: "bold" } },
              grid: { drawOnChartArea: false }
            }
          }
        }
      });

      return { entry, tp, sl };
    }

    async function computeEstimates(entryPrice, tp, sl) {
      const bal = await getJson(apiUrl("/balance"));
      const usd = Number(bal.balance?.ZUSD || 0);

      const amtEl = document.getElementById("tradeAmount");
      const pctEl = document.getElementById("investSelect");

      const amt = Number(amtEl.value || 0);
      const pct = Number(pctEl.value || 0);

      const invest = (amt > 0) ? amt : (usd * (pct / 100));
      const qty = invest > 0 ? (invest / entryPrice) : 0;

      const estProfit = (tp - entryPrice) * qty;
      const estLoss = (entryPrice - sl) * qty;

      return { usd, invest, qty, estProfit, estLoss };
    }

    async function placeOrder(pair, side, price, opts, isAuto) {
      const tp = Number(document.getElementById("tpInput")?.value || 0);
      const sl = Number(document.getElementById("slInput")?.value || 0);

      const bal = await getJson(apiUrl("/balance"));
      const usd = Number(bal.balance?.ZUSD || 0);

      const amt = Number(document.getElementById("tradeAmount")?.value || 0);
      const pct = Number(document.getElementById("investSelect")?.value || 0);
      const invest = (amt > 0) ? amt : (usd * (pct / 100));

      const payload = {
        pair,
        side,
        orderType: opts.orderType || "limit",
        price,
        price2: (opts.price2 === undefined ? null : opts.price2),
        takeProfit: tp,
        stopLoss: sl,
        investUsd: invest,
        isAuto: isAuto === true
      };

      try {
        return await postJson(apiUrl("/trade"), payload);
      } catch (e) {
        const msg = String(e.message || "");
        if (msg.includes("Invalid permissions") || msg.includes("trading restricted")) blockPair(pair);
        throw e;
      }
    }

    async function showStrategyModal(res) {
      const chartBuilt = buildModalChart(res);
      const rec = decideStrategyOrder(res, chartBuilt.entry, AGGRESSIVE_MODE);


      modalTitleEl.textContent = prettyPair(res.pair) + " " + res.signal;

      const recLine = rec
        ? ("<span class='good' style='font-weight:bold; font-size:18px;'>" + rec.actionTitle + "</span><span class='strategyTag'>" + rec.tag + "</span>")
        : ("<span class='warn' style='font-weight:bold; font-size:18px;'>No trade right now</span>");

      const recDetails = rec
        ? ("<div class='muted' style='margin-top:6px;'>" + rec.details + "</div>")
        : ("<div class='muted' style='margin-top:6px;'>Your rules do not see a safe entry. No trade is a valid outcome.</div>");

      const nextLine = rec && rec.next
        ? ("<div class='profitBox' style='margin-top:12px;'><div class='muted'>What to watch next</div><div style='margin-top:6px; font-weight:bold;'>" + rec.next + "</div></div>")
        : "";


      modalContentEl.innerHTML =
        "<div class='profitBox'>" +
        "<div class='rowFlex'>" +
        "<div>" +
        "<div class='muted'>Current price</div><div class='good' style='font-size:18px; font-weight:bold;'>" + chartBuilt.entry.toFixed(6) + "</div>" +
        "<div class='muted' style='margin-top:8px;'>RSI</div><div class='warn' style='font-size:16px; font-weight:bold;'>" + Number(res.rsi).toFixed(1) + "</div>" +
        "<div class='muted' style='margin-top:8px;'>Forecast change</div><div class='warn' style='font-size:16px; font-weight:bold;'>" + Number(res.predChange).toFixed(2) + " percent</div>" +
        "</div>" +
        "<div>" +
        "<div class='muted'>Decision</div>" +
        "<div style='margin-top:2px;'>" + recLine + "</div>" +
        recDetails +
        nextLine +
        "</div>" +
        "</div>" +
        "</div>" +
        "</div>" +

        "<div class='profitBox'>" +
        "<div class='rowFlex'>" +
        "<div>" +
        "<div class='muted'>Take profit</div><input id='tpInput' type='number' value='" + chartBuilt.tp.toFixed(6) + "'>" +
        "<div class='muted' style='margin-top:10px;'>Stop loss</div><input id='slInput' type='number' value='" + chartBuilt.sl.toFixed(6) + "'>" +
        "<div class='muted' style='margin-top:10px;'>Trade amount USD</div><input id='tradeAmount' type='number' value='5'>" +
        "<div class='muted' style='margin-top:10px;'>Or percent of USD</div>" +
        "<select id='investSelect'>" +
        "<option value='10'>10</option>" +
        "<option value='25'>25</option>" +
        "<option value='50'>50</option>" +
        "<option value='100'>100</option>" +
        "</select>" +
        "</div>" +

        "<div>" +
        "<div class='muted'>Strategy order preview</div>" +
        "<div id='orderPreviewBox' class='profitBox'></div>" +
        "<div class='muted' style='margin-top:10px;'>Balance and profit estimate</div>" +
        "<div id='estimateBox' class='profitBox'></div>" +
        "<button id='btnApprove' class='primaryBtn' " + (rec ? "" : "disabled") + ">‚úÖ Approve Strategy</button>" +
        "<div class='muted' style='margin-top:8px;'>Live trades may place exits only after entry fills.</div>" +
        "</div>" +
        "</div>" +
        "</div>";

      openModal();

      const estimateBox = document.getElementById("estimateBox");
      const orderPreviewBox = document.getElementById("orderPreviewBox");
      const approveBtn = document.getElementById("btnApprove");
      const pairInfo = await getPairInfo(res.pair);

      async function refreshEst() {
        try {
          const entryPrice = chartBuilt.entry;
          const tp = Number(document.getElementById("tpInput").value);
          const sl = Number(document.getElementById("slInput").value);

          const est = await computeEstimates(entryPrice, tp, sl);

          if (orderPreviewBox) {
            const amt = Number(document.getElementById("tradeAmount").value || 0);
            const pct = Number(document.getElementById("investSelect").value || 0);

            const modeTxt = (amt > 0) ? "Fixed USD" : ("Percent of USD " + pct.toFixed(0) + " percent");

            const sideTxt = rec ? String(rec.side).toUpperCase() : "N A";
            const typeTxt = rec ? String(rec.orderType) : "N A";
            const priceTxt = rec ? Number(rec.price).toFixed(6) : "0";
            const price2Txt = (rec && rec.price2 !== undefined && rec.price2 !== null) ? Number(rec.price2).toFixed(6) : "";

            orderPreviewBox.innerHTML =
              "<div class='muted'>Mode</div><div style='font-weight:bold;'>" + modeTxt + "</div>" +
              "<div class='muted' style='margin-top:8px;'>Side and type</div><div style='font-weight:bold;'>" + sideTxt + " " + typeTxt + "</div>" +
              "<div class='muted' style='margin-top:8px;'>Buy amount</div><div class='warn' style='font-weight:bold; font-size:16px;'>" + est.invest.toFixed(2) + " USD</div>" +
              "<div class='muted' style='margin-top:8px;'>Estimated quantity</div><div class='muted' style='font-weight:bold;'>" + est.qty.toFixed(6) + "</div>" +
              "<div class='muted' style='margin-top:8px;'>Entry trigger</div><div class='good' style='font-weight:bold;'>" + priceTxt + "</div>" +
              (price2Txt ? "<div class='muted' style='margin-top:8px;'>Entry limit</div><div class='good' style='font-weight:bold;'>" + price2Txt + "</div>" : "");
          }

          const minUsd = calcMinUsd(pairInfo, entryPrice);
          const tooSmall = (minUsd > 0 && est.invest > 0 && est.invest < minUsd);
          const overBalance = (est.invest > est.usd);

          estimateBox.innerHTML =
            "<div class='muted'>USD balance</div><div class='good' style='font-weight:bold; font-size:16px;'>" + est.usd.toFixed(4) + "</div>" +
            "<div class='muted' style='margin-top:8px;'>Buy amount</div><div class='" + (overBalance ? "bad" : (tooSmall ? "bad" : "warn")) + "' style='font-weight:bold; font-size:16px;'>" + est.invest.toFixed(2) + "</div>" +
            (minUsd > 0
              ? "<div class='muted' style='margin-top:8px;'>Minimum for this pair</div><div class='" + (tooSmall ? "bad" : "muted") + "' style='font-weight:bold; font-size:14px;'>" + minUsd.toFixed(2) + " USD</div>"
              : "") +
            "<div class='muted' style='margin-top:8px;'>Estimated profit at TP</div><div class='good' style='font-weight:bold; font-size:16px;'>" + est.estProfit.toFixed(4) + " USD</div>" +
            "<div class='muted' style='margin-top:8px;'>Estimated loss at SL</div><div class='bad' style='font-weight:bold; font-size:16px;'>" + est.estLoss.toFixed(4) + " USD</div>" +
            "<div class='muted' style='margin-top:6px;'>Estimates ignore fees and slippage.</div>" +
            (tooSmall ? "<div class='bad' style='margin-top:10px; font-weight:bold;'>Buy amount is below Kraken minimum. Increase to at least " + minUsd.toFixed(2) + " USD.</div>" : "");

          if (approveBtn) {
            approveBtn.disabled = (!rec) || tooSmall || (est.invest <= 0) || overBalance;
          }
        } catch {
          estimateBox.innerHTML = "<div class='bad'>Unable to load estimate</div>";
          if (approveBtn) approveBtn.disabled = true;
        }
      }

      document.getElementById("tpInput").addEventListener("input", refreshEst);
      document.getElementById("slInput").addEventListener("input", refreshEst);
      document.getElementById("tradeAmount").addEventListener("input", refreshEst);
      document.getElementById("investSelect").addEventListener("change", refreshEst);

      await refreshEst();

      if (approveBtn) {
        approveBtn.addEventListener("click", async () => {
          if (!rec) return;

          approveBtn.disabled = true;
          approveBtn.textContent = "Sending order...";

          try {
            const bal = await getJson(apiUrl("/balance"));
            const usd = Number(bal.balance?.ZUSD || 0);
            const amt = Number(document.getElementById("tradeAmount").value || 0);
            const pct = Number(document.getElementById("investSelect").value || 0);
            const invest = (amt > 0) ? amt : (usd * (pct / 100));

            const minUsd = calcMinUsd(pairInfo, chartBuilt.entry);
            if (minUsd > 0 && invest < minUsd) {
              alert("Kraken minimum for this pair is " + minUsd.toFixed(2) + " USD. Increase buy amount.");
              approveBtn.disabled = false;
              approveBtn.textContent = "‚úÖ Approve Strategy";
              return;
            }

            const result = await placeOrder(res.pair, rec.side, rec.price, { orderType: rec.orderType, price2: rec.price2 }, false);
            alert(String(result?.message || "Order sent"));
            await refreshUsdQuick();
            closeModal();
          } catch (e) {
            const p = e.payload || {};
            if (p && p.hint) alert(String(p.hint));
            else alert(String(e.message || "Order failed"));
            approveBtn.disabled = false;
            approveBtn.textContent = "‚úÖ Approve Strategy";
          }
        });
      }
    }

    async function analyze() {
      if (loggedOut) return;

      tableBodyEl.innerHTML = "";
      safeListEl.textContent = "Loading...";
      alertBoxEl.textContent = "Ranking pairs by 24h volume...";

      let pairs = [];
      try {
        const allPairs = await getAllUsdPairs();
        const filtered = allPairs.filter(p => !blockedPairs.has(p));
        pairs = await getTopPairsByVolumeUsd(filtered, MAX_SCAN_PAIRS);
      } catch (e) {
        alertBoxEl.textContent = "Failed to load pairs. " + String(e.message || e);
        safeListEl.textContent = "Unable to scan right now.";
        return;
      }

      const results = [];

      for (const p of pairs) {
        try {
          const d = await fetchOHLC(p);
          if (d.length < RSI_PERIOD + 1) continue;

          const closes = d.map(x => x.close);
          const rsi = calculateRSI_Wilder(closes, RSI_PERIOD);

          const x = closes.map((_, i) => i + 1);
          const lr = linearRegression(closes, x);

          const forecast = Array.from({ length: 5 }, (_, i) => lr.m * (x.length + i + 1) + lr.b);
          const predChange = ((forecast[forecast.length - 1] - closes[closes.length - 1]) / closes[closes.length - 1]) * 100;

          const rowObj = {
            pair: p,
            chartData: d,
            data: d.slice(-10),
            last: closes[closes.length - 1],
            rsi,
            predChange,
            score: buildScore(predChange, lr.m, rsi),
            signal: (rsi > 60 && predChange > 3) ? "üöÄ Strong Buy" : "‚è∏ Neutral",
            slope: lr.m,
            prices: closes,
            rsiHist: closes.map((_, i) => calculateRSI_Wilder(closes.slice(0, i + 1), RSI_PERIOD))
          };

          rowObj.recommended = decideStrategyOrder(rowObj, rowObj.last, AGGRESSIVE_MODE);

          results.push(rowObj);
        } catch (e) {
          console.error("Analyze failed for pair", p, e);
        }

      }

      const top10 = results
        .filter(r => r.predChange > 0)
        .sort((a, b) => b.score - a.score)
        .slice(0, 10);

      alertBoxEl.textContent = "Top 10 momentum coins ranked by score. Updated " + new Date().toLocaleTimeString();

      for (const r of top10) {
        const row = document.createElement("tr");
        if (r.predChange > 8) row.classList.add("highlightRow");

        row.innerHTML =
          "<td>" + prettyPair(r.pair) + "</td>" +
          "<td>" + r.last.toFixed(6) + "</td>" +
          "<td style='color:" + (r.predChange > 0 ? "lightgreen" : "red") + ";'>" + r.predChange.toFixed(2) + "%</td>" +
          "<td>" + r.rsi.toFixed(1) + "</td>" +
          "<td>" + r.score.toFixed(2) + "</td>" +
          "<td class='" + (r.signal.includes("Strong") ? "strongBuy" : "neutral") + "'>" + r.signal + "</td>";

        row.addEventListener("click", () => showStrategyModal(r));
        tableBodyEl.appendChild(row);
      }

      const safeTrades = results
        .filter(r => r.recommended && (r.recommended.quality || 0) >= 80)
        .sort((a, b) => (b.recommended.quality || 0) - (a.recommended.quality || 0))
        .slice(0, 3);

      try { await postJson(apiUrl("/api/alerts/safest"), { safeTrades }); } catch { }

      safeListEl.innerHTML = "";

      if (!safeTrades.length) {
        safeListEl.innerHTML = "<div class='muted'>No strategy approved entries right now.</div>";
        return;
      }

      for (const r of safeTrades) {
        const item = document.createElement("div");
        item.className = "safeTrade";

        const tag = r.recommended.tag;
        const action = r.recommended.actionTitle;

        item.innerHTML =
          "<span style='min-width:160px; font-weight:bold;'>" + prettyPair(r.pair) + "</span>" +
          "<span class='muted' style='flex:1 1 auto;'>" + action + "</span>" +
          "<span class='safeTag'>" + tag + "</span>" +
          "<span class='safeBadge'>Q " + (r.recommended.quality || 0) + "</span>";

        item.addEventListener("click", () => showStrategyModal(r));
        safeListEl.appendChild(item);
      }
    }

    async function autoTradeCycle() {
      if (!AUTO_TRADING_ALWAYS_ON) return;
      if (loggedOut) return;
    }

    document.getElementById("aggressiveToggle")?.addEventListener("change", (e) => {
      AGGRESSIVE_MODE = !!e.target.checked;
      localStorage.setItem("AGGRESSIVE_MODE", String(AGGRESSIVE_MODE));
      setAggressiveUi();
      analyze();
    });


    (async () => {
      setAggressiveUi();
      await ensureLoggedIn();
      await checkKrakenConnectedAndToggle();

      await refreshMode();
      await refreshUsdQuick();
      await analyze();

      startIntervals();
    })();
  </script>
</body>

</html>