<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: Arial, sans-serif; background-color: #0d1117; color: #e6edf3; margin: 0; padding: 20px; }
    h2 { color: #58a6ff; margin: 8px 0 12px 0; text-align: center; }

    .wrap { width: 92%; max-width: 1200px; margin: 0 auto; }
    .topBar { display: flex; justify-content: space-between; align-items: center; gap: 10px; flex-wrap: wrap; margin-bottom: 12px; }

    a.linkBtn, button.linkBtn {
      text-decoration: none; background: #58a6ff; color: #fff; font-weight: bold;
      border-radius: 10px; padding: 10px 14px; display: inline-block;
      border: none; cursor: pointer;
    }

    .panel { background: #161b22; border: 2px solid #30363d; border-radius: 10px; padding: 12px; margin-bottom: 12px; }

    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .row > div { flex: 1 1 360px; }

    input, select {
      border-radius: 8px; border: 1px solid #30363d; background: #0d1117;
      color: #e6edf3; padding: 9px 10px; width: 100%; box-sizing: border-box;
    }

    .muted { color: #8b949e; font-size: 12px; }
    .ok { color: lightgreen; font-weight: bold; }
    .warn { color: #ffcc00; font-weight: bold; }
    .bad { color: #ff5555; font-weight: bold; }

    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border-bottom: 1px solid #30363d; padding: 8px; text-align: left; font-size: 13px; vertical-align: top; }
    th { color: #58a6ff; font-size: 13px; }
    .smallBtn { padding: 8px 10px; border-radius: 8px; font-weight: bold; background: #58a6ff; color: #fff; border: none; cursor: pointer; }
    .smallBtn:disabled { opacity: 0.45; cursor: not-allowed; }

    canvas { width: 100%; height: 420px !important; }
    .chartBox { margin-top: 10px; }
    .splitCharts { display:flex; gap:12px; flex-wrap:wrap; }
    .splitCharts > div { flex: 1 1 520px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h2>Dashboard</h2>

    <div class="topBar">
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <a class="linkBtn" href="/account.html">Trades</a>
        <a class="linkBtn" href="/connect-kraken.html">Kraken</a>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button class="linkBtn" id="manualScanBtn">Manual Scan</button>
        <button class="linkBtn" id="logoutBtn">Logout</button>
      </div>
    </div>

    <div class="panel">
      <div class="row">
        <div>
          <div class="muted">Scan settings</div>
          <div style="margin-top:8px;">
            <label class="muted">Max pairs to scan</label>
            <input id="maxPairs" type="number" value="30" min="5" max="120" />
          </div>
          <div style="margin-top:8px;">
            <label class="muted">Quality minimum</label>
            <input id="qualityMin" type="number" value="80" min="0" max="100" />
          </div>
          <div style="margin-top:8px;">
            <label class="muted">Top results to show</label>
            <input id="topSend" type="number" value="3" min="1" max="15" />
          </div>
          <div style="margin-top:8px;">
            <label class="muted">Auto scan interval minutes</label>
            <input id="autoMinutes" type="number" value="10" min="1" max="120" />
          </div>
          <div class="muted" style="margin-top:10px;" id="scanStatus">Idle</div>
        </div>

        <div>
          <div class="muted">Quick actions</div>
          <div style="margin-top:8px;">
            <label class="muted">Open strategy page for a pair</label>
            <select id="pairSelect"></select>
          </div>
          <div style="margin-top:10px; display:flex; gap:10px;">
            <button class="smallBtn" id="openStrategyBtn">Open Strategy</button>
            <button class="smallBtn" id="refreshPairsBtn">Refresh Pairs</button>
          </div>
          <div class="muted" style="margin-top:10px;">
            Strategy opens in a new tab so you can approve without losing the dashboard.
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="muted">Safest trades found</div>
      <table>
        <thead>
          <tr>
            <th>Pair</th>
            <th>Side</th>
            <th>Quality</th>
            <th>Entry</th>
            <th>Take profit</th>
            <th>Stop loss</th>
            <th>Tag</th>
            <th>Open</th>
          </tr>
        </thead>
        <tbody id="safeBody">
          <tr><td colspan="8" class="muted">No results yet</td></tr>
        </tbody>
      </table>
    </div>

    <div class="panel">
      <div class="muted">All scan results</div>
      <table>
        <thead>
          <tr>
            <th>Pair</th>
            <th>Quality</th>
            <th>Tag</th>
            <th>Last</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody id="allBody">
          <tr><td colspan="5" class="muted">No scan yet</td></tr>
        </tbody>
      </table>
    </div>

    <div class="panel">
      <div class="muted">Charts</div>
      <div class="splitCharts chartBox">
        <div>
          <div class="muted">Last five hours to current</div>
          <canvas id="chartRecent"></canvas>
        </div>
        <div>
          <div class="muted">Four year forecast view</div>
          <canvas id="chartForecast"></canvas>
        </div>
      </div>
      <div class="muted" style="margin-top:10px;">
        The charts are split because squeezing five hours and four years into one chart makes both unreadable.
      </div>
    </div>
  </div>

  <script>
    function prettyPair(pair) {
      return String(pair || "").replace("X", "").replace("ZUSD", "/USD");
    }

    function round6(n) {
      const x = Number(n);
      if (!Number.isFinite(x)) return "0";
      return x.toFixed(6);
    }

    async function postJson(url, payload) {
      const r = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify(payload)
      });
      const t = await r.text();
      let j = {};
      try { j = JSON.parse(t); } catch { j = { raw: t }; }
      if (!r.ok) throw new Error(j.error || j.details || ("Request failed " + r.status));
      return j;
    }

    async function getJson(url) {
      const r = await fetch(url, { credentials: "include" });
      const t = await r.text();
      let j = {};
      try { j = JSON.parse(t); } catch { j = { raw: t }; }
      if (!r.ok) throw new Error(j.error || j.details || ("Request failed " + r.status));
      return j;
    }

    async function krakenPublicJson(url) {
      const r = await fetch(url);
      const j = await r.json();
      const err = Array.isArray(j.error) ? j.error.join(",") : "";
      if (err) throw new Error(err);
      return j.result || {};
    }

    function num(v) {
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    }

    function ema(values, period) {
      if (!Array.isArray(values) || values.length < period) return null;
      const k = 2 / (period + 1);
      let e = values.slice(0, period).reduce((a, b) => a + b, 0) / period;
      for (let i = period; i < values.length; i++) e = values[i] * k + e * (1 - k);
      return e;
    }

    function vwapFromCandles(candles) {
      if (!Array.isArray(candles) || !candles.length) return null;
      let pv = 0;
      let vol = 0;
      for (const c of candles) {
        const high = Number(c.high);
        const low = Number(c.low);
        const close = Number(c.close);
        const volume = Number(c.volume);
        if (!Number.isFinite(high) || !Number.isFinite(low) || !Number.isFinite(close) || !Number.isFinite(volume)) continue;
        const tp = (high + low + close) / 3;
        pv += tp * volume;
        vol += volume;
      }
      if (vol <= 0) return null;
      return pv / vol;
    }

    function approxPullbackSwingLow(closes, lookbackBars) {
      const n = Math.max(3, Number(lookbackBars || 10));
      if (!Array.isArray(closes) || closes.length < n) return null;
      let m = Infinity;
      for (let i = closes.length - n; i < closes.length; i++) m = Math.min(m, closes[i]);
      return Number.isFinite(m) ? m : null;
    }

    function approxPullbackSwingHigh(closes, lookbackBars) {
      const n = Math.max(3, Number(lookbackBars || 10));
      if (!Array.isArray(closes) || closes.length < n) return null;
      let m = -Infinity;
      for (let i = closes.length - n; i < closes.length; i++) m = Math.max(m, closes[i]);
      return Number.isFinite(m) ? m : null;
    }

    function decideStrategyOrder(res, currentPrice) {
      const h1 = res.h1 || [];
      const h4 = res.h4 || [];
      const m5 = res.m5 || [];

      const h1Closes = h1.map(x => x.close);
      const h4Closes = h4.map(x => x.close);
      const m5Closes = m5.map(x => x.close);

      if (h1Closes.length < 220 || h4Closes.length < 220 || m5Closes.length < 60) {
        return { quality: 0, tag: "Not enough data", side: null };
      }

      const ema200H1 = ema(h1Closes, 200);
      const ema200H4 = ema(h4Closes, 200);
      if (!Number.isFinite(ema200H1) || !Number.isFinite(ema200H4)) {
        return { quality: 0, tag: "EMA not ready", side: null };
      }

      const lastH1 = h1Closes[h1Closes.length - 1];
      const lastH4 = h4Closes[h4Closes.length - 1];

      const upBias = lastH1 > ema200H1 && lastH4 > ema200H4;
      const downBias = lastH1 < ema200H1 && lastH4 < ema200H4;

      const m5Ema20 = ema(m5Closes, 20);
      const m5Vwap = vwapFromCandles(m5);

      if (!Number.isFinite(m5Ema20) || !Number.isFinite(m5Vwap)) {
        return { quality: 0, tag: "M5 indicators missing", side: null };
      }

      const lastM5 = m5Closes[m5Closes.length - 1];
      const prevM5 = m5Closes[m5Closes.length - 2];

      const aboveEma = lastM5 > m5Ema20;
      const aboveVwap = lastM5 > m5Vwap;
      const reclaimLong = (prevM5 <= m5Ema20 || prevM5 <= m5Vwap) && (aboveEma && aboveVwap);

      const belowEma = lastM5 < m5Ema20;
      const belowVwap = lastM5 < m5Vwap;
      const reclaimShort = (prevM5 >= m5Ema20 || prevM5 >= m5Vwap) && (belowEma && belowVwap);

      if (!upBias && !downBias) return { quality: 0, tag: "Chop zone", side: null };

      if (upBias && reclaimLong) {
        const entry = currentPrice;
        const swingLow = approxPullbackSwingLow(m5Closes, 12);
        const stop = swingLow ? (swingLow * 0.999) : (entry * 0.992);
        const r = entry - stop;
        const tp = entry + (r * 2.0);

        return {
          quality: 85,
          tag: "Trend pullback reclaim",
          actionTitle: "Buy after pullback confirms",
          side: "buy",
          orderType: "limit",
          price: entry,
          stopLoss: stop,
          takeProfit: tp
        };
      }

      if (downBias && reclaimShort) {
        const entry = currentPrice;
        const swingHigh = approxPullbackSwingHigh(m5Closes, 12);
        const stop = swingHigh ? (swingHigh * 1.001) : (entry * 1.008);
        const r = stop - entry;
        const tp = entry - (r * 2.0);

        return {
          quality: 82,
          tag: "Trend pullback reclaim",
          actionTitle: "Sell after pullback confirms",
          side: "sell",
          orderType: "limit",
          price: entry,
          stopLoss: stop,
          takeProfit: tp
        };
      }

      return { quality: 0, tag: "No reclaim yet", side: null };
    }

    async function getAllUsdPairs() {
      const result = await krakenPublicJson("https://api.kraken.com/0/public/AssetPairs");
      const pairs = [];
      for (const key of Object.keys(result)) {
        const info = result[key];
        const wsname = info && info.wsname ? info.wsname : "";
        if (!wsname.endsWith("/USD")) continue;
        if (String(key).includes(".")) continue;
        pairs.push(key);
      }
      pairs.sort();
      return pairs;
    }

    async function fetchTickerBatch(pairsChunk) {
      const url = "https://api.kraken.com/0/public/Ticker?pair=" + encodeURIComponent(pairsChunk.join(","));
      return await krakenPublicJson(url);
    }

    async function getTopPairsByVolumeUsd(allPairs, topN) {
      const batchSize = 20;
      const scores = [];
      for (let i = 0; i < allPairs.length; i += batchSize) {
        const chunk = allPairs.slice(i, i + batchSize);
        let tick = {};
        try { tick = await fetchTickerBatch(chunk); } catch { tick = {}; }

        for (const pairKey of chunk) {
          const t = tick[pairKey];
          if (!t) continue;
          const last = Number(t.c && t.c[0]) || 0;
          const vol24 = Number(t.v && t.v[1]) || 0;
          const volUsd = last * vol24;
          if (volUsd > 0) scores.push({ pair: pairKey, volUsd });
        }
      }
      scores.sort((a, b) => b.volUsd - a.volUsd);
      return scores.slice(0, topN).map(x => x.pair);
    }

    async function fetchOHLC(pair, intervalMin, candles) {
      const url = "https://api.kraken.com/0/public/OHLC?pair=" + encodeURIComponent(pair) + "&interval=" + intervalMin;
      const result = await krakenPublicJson(url);
      const k = Object.keys(result).find(x => x !== "last");
      const arr = (k && Array.isArray(result[k])) ? result[k] : [];
      return arr.slice(-(candles || 60)).map(x => ({
        time: Number(x[0]),
        open: Number(x[1]),
        high: Number(x[2]),
        low: Number(x[3]),
        close: Number(x[4]),
        volume: Number(x[6])
      }));
    }

    function setScanStatus(txt, cls) {
      const el = document.getElementById("scanStatus");
      el.className = cls ? cls : "muted";
      el.textContent = txt;
    }

    function setTableSafe(items) {
      const body = document.getElementById("safeBody");
      if (!items.length) {
        body.innerHTML = "<tr><td colspan='8' class='muted'>No safe trades found</td></tr>";
        return;
      }

      body.innerHTML = items.map(x => {
        const rec = x.recommended || {};
        const url = "/strategy.html?pair=" + encodeURIComponent(x.pair);
        return (
          "<tr>" +
            "<td>" + prettyPair(x.pair) + "</td>" +
            "<td>" + String(rec.side || "") + "</td>" +
            "<td>" + String(rec.quality || 0) + "</td>" +
            "<td>" + round6(rec.price ?? x.last ?? 0) + "</td>" +
            "<td>" + round6(rec.takeProfit ?? 0) + "</td>" +
            "<td>" + round6(rec.stopLoss ?? 0) + "</td>" +
            "<td>" + String(rec.tag || "") + "</td>" +
            "<td><a class='linkBtn' style='padding:8px 10px; border-radius:8px;' target='_blank' rel='noopener' href='" + url + "'>Open</a></td>" +
          "</tr>"
        );
      }).join("");
    }

    function setTableAll(items) {
      const body = document.getElementById("allBody");
      if (!items.length) {
        body.innerHTML = "<tr><td colspan='5' class='muted'>No scan results</td></tr>";
        return;
      }

      body.innerHTML = items.map(x => {
        const rec = x.recommended || {};
        const q = Number(rec.quality || 0);
        const status = rec.side ? "signal" : (rec.tag || "none");
        return (
          "<tr>" +
            "<td>" + prettyPair(x.pair) + "</td>" +
            "<td>" + String(q) + "</td>" +
            "<td>" + String(rec.tag || "") + "</td>" +
            "<td>" + round6(x.last || 0) + "</td>" +
            "<td>" + String(status) + "</td>" +
          "</tr>"
        );
      }).join("");
    }

    let chartRecent = null;
    let chartForecast = null;

    function buildCharts(recentCandles, forecastPoints) {
      const recentLabels = recentCandles.map(c => {
        const d = new Date(c.time * 1000);
        return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      });
      const recentData = recentCandles.map(c => c.close);

      const ctx1 = document.getElementById("chartRecent");
      if (chartRecent) chartRecent.destroy();
      chartRecent = new Chart(ctx1, {
        type: "line",
        data: { labels: recentLabels, datasets: [{ label: "Price", data: recentData, borderWidth: 2, tension: 0.25, pointRadius: 0 }] },
        options: { responsive: true, maintainAspectRatio: false }
      });

      const forecastLabels = forecastPoints.map(p => {
        const d = new Date(p.timeMs);
        return d.toLocaleDateString([], { year: "numeric", month: "short" });
      });
      const forecastData = forecastPoints.map(p => p.value);

      const ctx2 = document.getElementById("chartForecast");
      if (chartForecast) chartForecast.destroy();
      chartForecast = new Chart(ctx2, {
        type: "line",
        data: { labels: forecastLabels, datasets: [{ label: "Forecast view", data: forecastData, borderWidth: 2, tension: 0.25, pointRadius: 0 }] },
        options: { responsive: true, maintainAspectRatio: false }
      });
    }

    function makeNaiveForecast(lastPrice) {
      const pts = [];
      const start = new Date();
      start.setDate(1);
      start.setHours(0, 0, 0, 0);

      let v = Number(lastPrice || 0);
      if (!Number.isFinite(v) || v <= 0) v = 1;

      for (let m = 0; m < 48; m++) {
        const d = new Date(start);
        d.setMonth(d.getMonth() + m);
        const wiggle = Math.sin(m / 3) * 0.02;
        const drift = 0.0015 * m;
        const val = v * (1 + drift + wiggle);
        pts.push({ timeMs: d.getTime(), value: val });
      }
      return pts;
    }

    async function loadPairDropdown() {
      const sel = document.getElementById("pairSelect");
      sel.innerHTML = "<option>Loading...</option>";
      let pairs = [];
      try { pairs = await getAllUsdPairs(); } catch { pairs = []; }

      if (!pairs.length) {
        sel.innerHTML = "<option value=''>No pairs</option>";
        return;
      }

      sel.innerHTML = pairs.slice(0, 250).map(p => {
        return "<option value='" + p + "'>" + prettyPair(p) + "</option>";
      }).join("");
    }

    async function doLogout() {
      try { await postJson("/api/logout", {}); } catch {}
      window.location.replace("/login.html");
    }

    async function runScan() {
      const maxPairs = Math.max(5, Math.min(120, Number(document.getElementById("maxPairs").value || 30)));
      const qualityMin = Math.max(0, Math.min(100, Number(document.getElementById("qualityMin").value || 80)));
      const topSend = Math.max(1, Math.min(15, Number(document.getElementById("topSend").value || 3)));

      setScanStatus("Scanning top volume USD pairs...", "warn");

      let allPairs = [];
      try { allPairs = await getAllUsdPairs(); } catch { allPairs = []; }

      if (!allPairs.length) {
        setScanStatus("Failed to load pairs from Kraken", "bad");
        return;
      }

      let topPairs = [];
      try { topPairs = await getTopPairsByVolumeUsd(allPairs, maxPairs); } catch { topPairs = []; }

      if (!topPairs.length) {
        setScanStatus("No top pairs returned", "bad");
        return;
      }

      const results = [];

      for (const p of topPairs) {
        try {
          const h1p = fetchOHLC(p, 60, 260);
          const h4p = fetchOHLC(p, 240, 260);
          const m5p = fetchOHLC(p, 5, 120);
          const h1 = await h1p;
          const h4 = await h4p;
          const m5 = await m5p;

          const last = m5.length ? m5[m5.length - 1].close : (h1.length ? h1[h1.length - 1].close : 0);
          const rowObj = { pair: p, h1, h4, m5, last };
          rowObj.recommended = decideStrategyOrder(rowObj, last);
          results.push(rowObj);
        } catch {
        }
      }

      results.sort((a, b) => Number(b.recommended?.quality || 0) - Number(a.recommended?.quality || 0));

      const safe = results.filter(x => Number(x.recommended?.quality || 0) >= qualityMin).slice(0, topSend);

      setTableAll(results);
      setTableSafe(safe);

      setScanStatus("Scan done. Found " + safe.length + " safe trades.", safe.length ? "ok" : "muted");

      const first = safe[0] || results[0];
      if (first && first.m5 && first.m5.length) {
        const m5 = first.m5;
        const recent = m5.slice(-60);
        const lastPrice = recent.length ? recent[recent.length - 1].close : first.last;
        const forecast = makeNaiveForecast(lastPrice);
        buildCharts(recent, forecast);
      }
    }

    function openStrategyForSelected() {
      const pair = document.getElementById("pairSelect").value;
      if (!pair) return;
      const url = "/strategy.html?pair=" + encodeURIComponent(pair);
      window.open(url, "_blank", "noopener");
    }

    let autoTimer = null;

    function restartAutoScan() {
      if (autoTimer) clearInterval(autoTimer);
      const mins = Math.max(1, Math.min(120, Number(document.getElementById("autoMinutes").value || 10)));
      autoTimer = setInterval(() => {
        runScan().catch(() => {});
      }, mins * 60 * 1000);
    }

    document.getElementById("logoutBtn").addEventListener("click", doLogout);
    document.getElementById("manualScanBtn").addEventListener("click", () => runScan());
    document.getElementById("refreshPairsBtn").addEventListener("click", () => loadPairDropdown());
    document.getElementById("openStrategyBtn").addEventListener("click", openStrategyForSelected);
    document.getElementById("autoMinutes").addEventListener("change", restartAutoScan);

    (async () => {
      await loadPairDropdown();
      restartAutoScan();
      await runScan();
    })();
  </script>
</body>
</html>
