<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>üöÄ Namu Trading</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #0d1117;
      color: #e6edf3;
      text-align: center;
      margin: 0;
      padding: 20px;
    }

    h2 {
      color: #58a6ff;
      margin: 8px 0 10px 0;
    }

    .topBar {
      width: 92%;
      max-width: 1100px;
      margin: 0 auto 12px auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .pill {
      background: #161b22;
      border: 2px solid #30363d;
      padding: 10px 12px;
      border-radius: 10px;
      color: #e6edf3;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    a.linkBtn,
    button.linkBtn {
      text-decoration: none;
      background: #58a6ff;
      color: #fff;
      font-weight: bold;
      border-radius: 10px;
      padding: 10px 14px;
      display: inline-block;
      border: none;
      cursor: pointer;
    }

    a.linkBtn:hover,
    button.linkBtn:hover {
      filter: brightness(1.05);
    }

    #alertBox {
      background-color: #161b22;
      border: 2px solid #30363d;
      padding: 15px;
      border-radius: 10px;
      width: 92%;
      max-width: 1100px;
      margin: 0 auto 14px auto;
      text-align: left;
    }

    #safePanel {
      width: 92%;
      max-width: 1100px;
      margin: 12px auto;
      padding: 12px;
      background: #161b22;
      border: 2px solid #30363d;
      border-radius: 10px;
      text-align: left;
    }

    #safePanel h3 {
      margin: 0 0 10px 0;
    }

    .muted {
      color: #8b949e;
      font-size: 12px;
    }

    .safeTrade {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #0d1117;
      border-radius: 8px;
      padding: 10px 14px;
      margin: 8px 0;
      cursor: pointer;
      transition: 0.3s;
      gap: 12px;
    }

    .safeTrade:hover {
      background: #1f6feb33;
    }

    .safeBadge {
      font-size: 12px;
      font-weight: bold;
      border-radius: 6px;
      padding: 4px 8px;
      background: #00c85333;
      color: lightgreen;
      white-space: nowrap;
    }

    .safeTag {
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #30363d;
      background: #0d1117;
      color: #e6edf3;
      white-space: nowrap;
    }

    table {
      width: 92%;
      max-width: 1100px;
      margin: 16px auto;
      border-collapse: collapse;
    }

    th,
    td {
      padding: 10px;
      border: 1px solid #30363d;
      cursor: pointer;
    }

    th {
      background-color: #161b22;
    }

    tr:hover {
      background-color: #1f6feb44;
    }

    .strongBuy {
      color: lightgreen;
      font-weight: bold;
    }

    .neutral {
      color: #ffcc00;
    }

    .highlightRow {
      box-shadow: 0 0 12px 2px rgba(0, 255, 0, 0.3);
      animation: pulse 1.8s infinite alternate;
    }

    @keyframes pulse {
      from {
        box-shadow: 0 0 6px rgba(0, 255, 0, 0.1);
      }

      to {
        box-shadow: 0 0 14px rgba(0, 255, 0, 0.5);
      }
    }

    footer {
      margin-top: 20px;
      color: #8b949e;
    }

    a.coinLink {
      color: #58a6ff;
      font-weight: bold;
      text-decoration: none;
    }

    a.coinLink:hover {
      text-decoration: underline;
    }
  </style>
</head>

<body>
  <h2>üöÄ Namu Trading Dashboard</h2>

  <div class="topBar">
    <div class="pill">
      <span class="warn">Live trading</span>
      <span class="muted" id="usdQuick">ZUSD loading</span>
      <span class="muted" id="modeBadge"></span>
      <span class="muted" id="authBadge"></span>
    </div>

    <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
      <label class="pill" style="cursor:pointer;">
        <input id="aggressiveToggle" type="checkbox" style="width:auto; margin:0 8px 0 0;">
        <span style="font-weight:bold;">Aggressive Mode</span>
        <span class="muted" id="aggressiveBadge">Off</span>
      </label>

      <a id="connectKrakenBtn" class="linkBtn" href="/connect-kraken.html">üîë Connect Kraken</a>
      <a class="linkBtn" href="/account.html">üìí Trades</a>
      <button class="linkBtn" id="logoutBtn">üö™ Logout</button>
    </div>
  </div>

  <div id="safePanel">
    <h3>üõ°Ô∏è Safest Trades Right Now</h3>
    <div class="muted">This list only shows fresh reclaim setups from the last few five minute candles.</div>
    <div id="safeTradesList">Loading...</div>
  </div>

  <div id="alertBox">Fetching market data...</div>

  <table id="results">
    <thead>
      <tr>
        <th>Coin</th>
        <th>Price</th>
        <th>Forecast Change</th>
        <th>RSI</th>
        <th>Score</th>
        <th>Signal</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <footer>üìä Created by Colin Rika</footer>

  <script>
    const MAX_SCAN_PAIRS = 60;
    const RSI_PERIOD = 14;

    const H1_INTERVAL_MIN = 60;
    const H4_INTERVAL_MIN = 240;
    const M5_INTERVAL_MIN = 5;

    const H1_CANDLES = 260;
    const H4_CANDLES = 260;
    const M5_CANDLES = 180;

    const blockedPairs = new Set(JSON.parse(localStorage.getItem("blockedPairs") || "[]"));

    const alertBoxEl = document.getElementById("alertBox");
    const safeListEl = document.getElementById("safeTradesList");
    const tableBodyEl = document.querySelector("#results tbody");

    let SIMULATOR = false;
    let AGGRESSIVE_MODE = String(localStorage.getItem("AGGRESSIVE_MODE") || "false").toLowerCase() === "true";

    let intervalIds = [];
    let loggedOut = false;
    let redirecting = false;

    function apiUrl(p) { return window.location.origin + p; }
    function parseTotalZusd(resp) {
      const total = Number(resp?.balance?.ZUSD);
      return Number.isFinite(total) ? total : 0;
    }
    function parseAvailableZusd(resp) {
      const candidates = [
        Number(resp?.availableZusd),
        Number(resp?.tradeBalance?.mf),
        Number(resp?.tradeBalance?.tb),
        Number(resp?.tradeBalance?.eb),
        Number(resp?.tradeBalance?.e)
      ];
      for (const v of candidates) {
        if (Number.isFinite(v)) return v;
      }
      return parseTotalZusd(resp);
    }

    function setAggressiveUi() {
      const cb = document.getElementById("aggressiveToggle");
      const badge = document.getElementById("aggressiveBadge");
      if (cb) cb.checked = AGGRESSIVE_MODE;
      if (badge) badge.textContent = AGGRESSIVE_MODE ? "On" : "Off";
    }

    function startIntervals() {
      intervalIds.push(setInterval(refreshMode, 30000));
      intervalIds.push(setInterval(refreshUsdQuick, 30000));
      intervalIds.push(setInterval(analyze, 300000));
    }

    function stopIntervals() {
      for (const id of intervalIds) clearInterval(id);
      intervalIds = [];
    }

    function redirectToLoginOnce() {
      if (redirecting) return;
      redirecting = true;
      loggedOut = true;
      stopIntervals();
      window.location.replace("/login.html");
    }

    function toggleAccountAccess(loggedIn) {
      const btn = document.querySelector("a[href='/account.html']");
      if (!btn) return;
      btn.style.display = loggedIn ? "inline-block" : "none";
    }

    async function getJson(url) {
      const resp = await fetch(url, { credentials: "include" });
      const text = await resp.text();
      let data = {};
      try { data = JSON.parse(text); } catch { data = { raw: text }; }

      if (!resp.ok) {
        if (resp.status === 401) {
          redirectToLoginOnce();
          throw new Error("Unauthorized");
        }
        const err = new Error(data?.details || data?.error || ("Request failed " + resp.status));
        err.payload = data;
        throw err;
      }
      return data;
    }

    async function postJson(url, payload) {
      const resp = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        credentials: "include"
      });

      const text = await resp.text();
      let data = {};
      try { data = JSON.parse(text); } catch { data = { raw: text }; }

      if (!resp.ok) {
        if (resp.status === 401) {
          redirectToLoginOnce();
          throw new Error("Unauthorized");
        }
        const err = new Error(data?.details || data?.error || ("Request failed " + resp.status));
        err.payload = data;
        throw err;
      }
      return data;
    }

    async function ensureLoggedIn() {
      try {
        await getJson(apiUrl("/balance"));
        document.getElementById("authBadge").textContent = "Logged in";
        toggleAccountAccess(true);
      } catch {
        toggleAccountAccess(false);
        redirectToLoginOnce();
      }
    }

    function hideConnectBtn() {
      const btn = document.getElementById("connectKrakenBtn");
      if (btn) btn.style.display = "none";
    }

    function showConnectBtn() {
      const btn = document.getElementById("connectKrakenBtn");
      if (btn) btn.style.display = "inline-block";
    }

    async function checkKrakenConnectedAndToggle() {
      try {
        const s = await getJson(apiUrl("/api/account/status"));

        const raw =
          s?.krakenConnected ??
          s?.connected ??
          s?.isConnected ??
          s?.data?.krakenConnected ??
          s?.data?.connected;

        const connected = raw === true || raw === "true" || raw === 1 || raw === "1";

        if (connected) {
          hideConnectBtn();
          return;
        }
      } catch {
      }

      try {
        const d = await getJson(apiUrl("/balance"));
        const usd = Number(d?.balance?.ZUSD);
        if (Number.isFinite(usd)) {
          hideConnectBtn();
          return;
        }
      } catch {
      }

      showConnectBtn();
    }

    async function doLogout() {
      loggedOut = true;
      stopIntervals();
      try { await postJson(apiUrl("/api/logout"), {}); } catch { }
      redirectToLoginOnce();
    }

    document.getElementById("logoutBtn").addEventListener("click", doLogout);

    async function refreshMode() {
      if (loggedOut) return;
      try {
        const m = await getJson(apiUrl("/mode"));
        SIMULATOR = m && m.simulator === true;
        document.getElementById("modeBadge").textContent = SIMULATOR ? "Simulator ON" : "Simulator OFF";
      } catch {
        SIMULATOR = false;
        document.getElementById("modeBadge").textContent = "";
      }
    }

    async function refreshUsdQuick() {
      if (loggedOut) return;
      try {
        const d = await getJson(apiUrl("/balance"));
        const totalZusd = parseTotalZusd(d);
        const avail = parseAvailableZusd(d);
        const ts = new Date().toLocaleTimeString();
        document.getElementById("usdQuick").textContent =
          "ZUSD available " + avail.toFixed(4) + " total " + totalZusd.toFixed(4) + " updated " + ts;
      } catch {
        document.getElementById("usdQuick").textContent = "ZUSD unavailable";
      }
    }

    function prettyPair(pair) { return String(pair).replace("X", "").replace("ZUSD", "/USD"); }

    function openStrategyPage(pair) {
      const url = "/strategy.html?pair=" + encodeURIComponent(pair);
      window.open(url, "_blank", "noopener,noreferrer");
    }

    function strategyHref(pair) {
      return "/strategy.html?pair=" + encodeURIComponent(pair);
    }

    async function getAllUsdPairs() {
      const r = await fetch("https://api.kraken.com/0/public/AssetPairs");
      const j = await r.json();
      const result = j.result || {};
      const pairs = [];

      for (const key of Object.keys(result)) {
        const info = result[key];
        const wsname = info?.wsname || "";
        if (!wsname.endsWith("/USD")) continue;
        if (String(key).includes(".")) continue;
        pairs.push(key);
      }
      return pairs;
    }

    async function fetchTickerBatch(pairsChunk) {
      const url = "https://api.kraken.com/0/public/Ticker?pair=" + encodeURIComponent(pairsChunk.join(","));
      const r = await fetch(url);
      const j = await r.json();
      return j.result || {};
    }

    async function getTopPairsByVolumeUsd(allPairs, topN) {
      const pairs = allPairs.slice();
      const batchSize = 20;
      const scores = [];

      for (let i = 0; i < pairs.length; i += batchSize) {
        const chunk = pairs.slice(i, i + batchSize);
        let tick = {};
        try { tick = await fetchTickerBatch(chunk); } catch { tick = {}; }

        for (const pairKey of chunk) {
          const t = tick[pairKey];
          if (!t) continue;

          const last = Number(t.c && t.c[0]) || 0;
          const vol24 = Number(t.v && t.v[1]) || 0;
          const volUsd = last * vol24;

          if (volUsd > 0) scores.push({ pair: pairKey, volUsd });
        }
      }

      scores.sort((a, b) => b.volUsd - a.volUsd);
      return scores.slice(0, topN).map(x => x.pair);
    }

    async function fetchOHLC(pair, intervalMin, candles) {
      const r = await fetch("https://api.kraken.com/0/public/OHLC?pair=" + encodeURIComponent(pair) + "&interval=" + intervalMin);
      const j = await r.json();
      const k = Object.keys(j.result || {}).find(x => x !== "last");
      if (!k || !Array.isArray(j.result[k])) return [];

      return j.result[k].slice(-(candles || 60)).map(x => ({
        time: new Date(x[0] * 1000).toLocaleTimeString([], { hour: "numeric", minute: "2-digit" }),
        open: Number(x[1]),
        high: Number(x[2]),
        low: Number(x[3]),
        close: Number(x[4]),
        volume: Number(x[6])
      }));
    }

    function linearRegression(y, x) {
      const n = y.length;
      const sumx = x.reduce((a, b) => a + b, 0);
      const sumy = y.reduce((a, b) => a + b, 0);
      const sumxy = y.reduce((a, b, i) => a + b * x[i], 0);
      const sumxx = x.reduce((a, b) => a + b * b, 0);
      const denom = (n * sumxx - sumx * sumx);
      const m = denom === 0 ? 0 : (n * sumxy - sumx * sumy) / denom;
      const b = (sumy - m * sumx) / n;
      return { m, b };
    }

    function calculateRSI_Wilder(closes, period) {
      if (!Array.isArray(closes) || closes.length < period + 1) return 50;

      let gains = 0;
      let losses = 0;

      for (let i = 1; i <= period; i++) {
        const delta = closes[i] - closes[i - 1];
        if (delta >= 0) gains += delta;
        else losses -= delta;
      }

      let avgGain = gains / period;
      let avgLoss = losses / period;

      for (let i = period + 1; i < closes.length; i++) {
        const delta = closes[i] - closes[i - 1];
        const gain = delta > 0 ? delta : 0;
        const loss = delta < 0 ? -delta : 0;
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;
      }

      if (avgLoss === 0) return 100;
      const rs = avgGain / avgLoss;
      return 100 - (100 / (1 + rs));
    }

    function buildScore(predChange, trendSlope, rsi) {
      const bonusMidRsi = (rsi >= 50 && rsi <= 65) ? 5 : 0;
      const penaltyOverbought = (rsi > 70) ? 10 : 0;
      return (predChange * 2) + (trendSlope * 10) + bonusMidRsi - penaltyOverbought;
    }

    async function analyze() {
      if (loggedOut) return;

      tableBodyEl.innerHTML = "";
      safeListEl.textContent = "Loading...";
      alertBoxEl.textContent = "Ranking pairs by 24h volume...";

      let pairs = [];
      try {
        const allPairs = await getAllUsdPairs();
        const filtered = allPairs.filter(p => !blockedPairs.has(p));
        pairs = await getTopPairsByVolumeUsd(filtered, MAX_SCAN_PAIRS);
      } catch (e) {
        alertBoxEl.textContent = "Failed to load pairs. " + String(e.message || e);
        safeListEl.textContent = "Unable to scan right now.";
        return;
      }

      const results = [];

      for (const p of pairs) {
        try {
          const h1 = await fetchOHLC(p, H1_INTERVAL_MIN, H1_CANDLES);
          const h4 = await fetchOHLC(p, H4_INTERVAL_MIN, H4_CANDLES);
          const m5 = await fetchOHLC(p, M5_INTERVAL_MIN, M5_CANDLES);

          if (h1.length < RSI_PERIOD + 1) continue;
          if (h1.length < 220 || h4.length < 220 || m5.length < 60) continue;

          const closes = h1.map(x => x.close);
          const rsi = calculateRSI_Wilder(closes, RSI_PERIOD);

          const x = closes.map((_, i) => i + 1);
          const lr = linearRegression(closes, x);

          const forecast = Array.from({ length: 5 }, (_, i) => lr.m * (x.length + i + 1) + lr.b);
          const predChange = ((forecast[forecast.length - 1] - closes[closes.length - 1]) / closes[closes.length - 1]) * 100;

          results.push({
            pair: p,
            last: closes[closes.length - 1],
            rsi,
            predChange,
            score: buildScore(predChange, lr.m, rsi),
            signal: (rsi > 60 && predChange > 3) ? "üöÄ Strong Buy" : "‚è∏ Neutral"
          });
        } catch (e) {
          console.error("Analyze failed for pair", p, e);
        }
      }

      const top10 = results
        .filter(r => r.predChange > 0)
        .sort((a, b) => b.score - a.score)
        .slice(0, 10);

      alertBoxEl.textContent = "Top 10 momentum coins ranked by score. Updated " + new Date().toLocaleTimeString();

      for (const r of top10) {
        const row = document.createElement("tr");
        if (r.predChange > 8) row.classList.add("highlightRow");

        const pairText = prettyPair(r.pair);
        const href = strategyHref(r.pair);

        row.innerHTML =
          "<td>" +
          "<a class='coinLink' href='" + href + "' target='_blank' rel='noopener noreferrer'>" + pairText + "</a>" +
          "</td>" +
          "<td>" + r.last.toFixed(6) + "</td>" +
          "<td style='color:" + (r.predChange > 0 ? "lightgreen" : "red") + ";'>" + r.predChange.toFixed(2) + "%</td>" +
          "<td>" + r.rsi.toFixed(1) + "</td>" +
          "<td>" + r.score.toFixed(2) + "</td>" +
          "<td class='" + (r.signal.includes("Strong") ? "strongBuy" : "neutral") + "'>" + r.signal + "</td>";

        row.addEventListener("click", (ev) => {
          const tag = String(ev.target && ev.target.tagName || "");
          if (tag.toLowerCase() === "a") return;
          openStrategyPage(r.pair);
        });

        tableBodyEl.appendChild(row);
      }

      let safeTrades = [];
      try {
        const safest = await getJson(apiUrl("/api/alerts/safest"));
        const arr = safest?.safeTrades;
        if (Array.isArray(arr)) safeTrades = arr;
      } catch {
      }

      /**
      try {
        await postJson(apiUrl("/api/alerts/safest"), { safeTrades });
      } catch (e) {
        console.log("Safest trade POST failed", e?.message || e);
      }
      **/

      safeListEl.innerHTML = "";

      if (!safeTrades.length) {
        safeListEl.innerHTML = "<div class='muted'>No fresh reclaim setups right now.</div>";
        return;
      }

      for (const r of safeTrades) {
        const pair = r?.pair;
        const rec = r?.recommended || {};
        if (!pair) continue;

        const item = document.createElement("div");
        item.className = "safeTrade";

        const tag = rec.tag || "";
        const action = rec.actionTitle || "";
        const barsAgo = (rec.freshBarsAgo !== null && rec.freshBarsAgo !== undefined)
          ? ("Fresh " + String(rec.freshBarsAgo) + " bars ago")
          : "Fresh";

        item.innerHTML =
          "<span style='min-width:160px; font-weight:bold;'>" + prettyPair(pair) + "</span>" +
          "<span class='muted' style='flex:1 1 auto;'>" + action + "</span>" +
          "<span class='safeTag'>" + tag + "</span>" +
          "<span class='safeTag'>" + barsAgo + "</span>" +
          "<span class='safeBadge'>Q " + (rec.quality || 0) + "</span>";

        item.addEventListener("click", () => openStrategyPage(pair));
        safeListEl.appendChild(item);
      }
    }

    document.getElementById("aggressiveToggle")?.addEventListener("change", (e) => {
      AGGRESSIVE_MODE = !!e.target.checked;
      localStorage.setItem("AGGRESSIVE_MODE", String(AGGRESSIVE_MODE));
      setAggressiveUi();
      analyze();
    });

    (async () => {
      setAggressiveUi();
      await ensureLoggedIn();
      await checkKrakenConnectedAndToggle();

      await refreshMode();
      await refreshUsdQuick();
      await analyze();

      startIntervals();
    })();
  </script>
</body>

</html>
