<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ðŸ“ˆ Dashboard</title>
  <style>
    body { font-family: Arial, sans-serif; background-color: #0d1117; color: #e6edf3; margin: 0; padding: 20px; }
    h2 { color: #58a6ff; margin: 8px 0 12px 0; text-align: center; }

    .wrap { width: 92%; max-width: 1200px; margin: 0 auto; }
    .topBar { display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap; margin-bottom:12px; }

    a.linkBtn, button.linkBtn {
      text-decoration:none; background:#58a6ff; color:#fff; font-weight:bold;
      border-radius:10px; padding:10px 14px; display:inline-block; border:none; cursor:pointer;
    }
    a.linkBtn:hover, button.linkBtn:hover { filter: brightness(1.05); }
    button.grayBtn { background:#30363d; }

    .panel { background: #161b22; border: 2px solid #30363d; border-radius: 10px; padding: 12px; margin-bottom: 12px; }
    .panel h3 { margin: 0 0 10px 0; font-size: 16px; }

    .kvRow { display:flex; justify-content:space-between; gap:10px; border-bottom:1px solid rgba(255,255,255,0.06); padding:6px 0; }
    .kvRow:last-child { border-bottom:none; }

    .muted { color:#8b949e; font-size:12px; }
    .good { color: lightgreen; }
    .bad { color:#ff5555; }
    .warn { color:#ffcc00; }

    .controls { display:flex; gap:10px; flex-wrap:wrap; align-items:end; }
    .control { display:flex; flex-direction:column; gap:6px; }
    input, select {
      border-radius:10px; border:1px solid #30363d; background:#0d1117; color:#e6edf3;
      padding:10px 12px; width:220px; box-sizing:border-box;
    }

    table { width:100%; border-collapse:collapse; margin-top:10px; }
    th, td { padding:10px; border:1px solid #30363d; vertical-align:top; }
    th { background:#0d1117; text-align:left; }
    tr.clickable { cursor:pointer; }
    tr.clickable:hover { background: rgba(88,166,255,0.08); }

    .pill { background:#0d1117; border:1px solid #30363d; border-radius:999px; padding:6px 10px; display:inline-block; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width: 900px) { .grid2 { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <h2>ðŸ“ˆ Dashboard</h2>

    <div class="topBar">
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <a class="linkBtn" href="/account.html">ðŸ“’ Account</a>
        <a class="linkBtn" href="/connect-kraken.html">ðŸ”‘ Kraken</a>
        <button class="linkBtn grayBtn" id="btnLogout">Logout</button>
      </div>
      <div class="pill">
        <span class="muted">USD </span><span id="usdBal" class="good" style="font-weight:bold;">0.0000</span>
        <span class="muted" style="margin-left:10px;">Updated </span><span id="updated" class="muted"></span>
      </div>
    </div>

    <div class="panel">
      <h3>Scanner</h3>
      <div class="controls">
        <div class="control">
          <div class="muted">Max scan pairs</div>
          <input id="maxPairs" type="number" value="30" min="5" max="200" />
        </div>
        <div class="control">
          <div class="muted">Quality minimum</div>
          <input id="minQuality" type="number" value="80" min="0" max="100" />
        </div>
        <div class="control">
          <div class="muted">Top results</div>
          <input id="topSend" type="number" value="10" min="1" max="50" />
        </div>
        <div class="control">
          <button class="linkBtn" id="btnScan">Scan now</button>
        </div>
        <div class="control">
          <button class="linkBtn grayBtn" id="btnAuto">Auto scan on</button>
        </div>
      </div>
      <div class="muted" style="margin-top:10px;" id="scanStatus">Idle</div>
    </div>

    <div class="grid2">
      <div class="panel">
        <h3>Safest trades</h3>
        <div class="muted">Click a row to open its strategy page in a new tab.</div>
        <table>
          <thead>
            <tr>
              <th>Pair</th>
              <th>Side</th>
              <th>Quality</th>
              <th>Entry</th>
              <th>TP</th>
              <th>SL</th>
              <th>Tag</th>
            </tr>
          </thead>
          <tbody id="safeBody"></tbody>
        </table>
      </div>

      <div class="panel">
        <h3>Status</h3>
        <div id="statusBox">
          <div class="kvRow"><span class="muted">Email verified</span><span class="muted">...</span></div>
          <div class="kvRow"><span class="muted">Kraken connected</span><span class="muted">...</span></div>
          <div class="kvRow"><span class="muted">Mode</span><span class="muted">...</span></div>
        </div>
        <div class="muted" style="margin-top:10px;">
          If scan shows nothing, it usually means you are in chop or you do not have a fresh reclaim candle.
        </div>
      </div>
    </div>
  </div>

  <script>
    let autoOn = false;
    let autoTimer = null;

    function apiUrl(p) { return window.location.origin + p; }

    async function getJson(url) {
      const r = await fetch(url, { credentials: "include" });
      const t = await r.text();
      let d = {};
      try { d = JSON.parse(t); } catch { d = { raw: t }; }

      if (!r.ok) {
        if (r.status === 401) {
          window.location.replace("/login.html?next=" + encodeURIComponent(window.location.pathname + window.location.search));
          throw new Error("Unauthorized");
        }
        throw new Error(d.error || d.details || ("Request failed " + r.status));
      }
      return d;
    }

    async function postJson(url, payload) {
      const r = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        credentials: "include"
      });
      const t = await r.text();
      let d = {};
      try { d = JSON.parse(t); } catch { d = { raw: t }; }

      if (!r.ok) {
        if (r.status === 401) {
          window.location.replace("/login.html?next=" + encodeURIComponent(window.location.pathname + window.location.search));
          throw new Error("Unauthorized");
        }
        throw new Error(d.error || d.details || ("Request failed " + r.status));
      }
      return d;
    }

    function num(v) {
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    }

    function ema(values, period) {
      if (!Array.isArray(values) || values.length < period) return null;
      const k = 2 / (period + 1);

      let e = values.slice(0, period).reduce((a, b) => a + b, 0) / period;
      for (let i = period; i < values.length; i++) {
        e = values[i] * k + e * (1 - k);
      }
      return e;
    }

    function vwapFromCandles(candles) {
      if (!Array.isArray(candles) || !candles.length) return null;

      let pv = 0;
      let vol = 0;

      for (const c of candles) {
        const high = Number(c.high);
        const low = Number(c.low);
        const close = Number(c.close);
        const volume = Number(c.volume);

        if (!Number.isFinite(high) || !Number.isFinite(low) || !Number.isFinite(close) || !Number.isFinite(volume)) continue;

        const tp = (high + low + close) / 3;
        pv += tp * volume;
        vol += volume;
      }

      if (vol <= 0) return null;
      return pv / vol;
    }

    function approxPullbackSwingLow(closes, lookbackBars) {
      const n = Math.max(3, Number(lookbackBars || 10));
      if (!Array.isArray(closes) || closes.length < n) return null;
      let m = Infinity;
      for (let i = closes.length - n; i < closes.length; i++) m = Math.min(m, closes[i]);
      return Number.isFinite(m) ? m : null;
    }

    function approxPullbackSwingHigh(closes, lookbackBars) {
      const n = Math.max(3, Number(lookbackBars || 10));
      if (!Array.isArray(closes) || closes.length < n) return null;
      let m = -Infinity;
      for (let i = closes.length - n; i < closes.length; i++) m = Math.max(m, closes[i]);
      return Number.isFinite(m) ? m : null;
    }

    function round6(n) {
      const x = Number(n);
      if (!Number.isFinite(x)) return "0";
      return x.toFixed(6);
    }

    function prettyPair(pair) {
      return String(pair || "").replace("X", "").replace("ZUSD", "/USD");
    }

    async function getAllUsdPairs() {
      const r = await fetch("https://api.kraken.com/0/public/AssetPairs");
      const j = await r.json();
      const result = j.result || {};
      const pairs = [];

      for (const key of Object.keys(result)) {
        const info = result[key];
        const wsname = info && info.wsname ? info.wsname : "";
        if (!wsname.endsWith("/USD")) continue;
        if (String(key).includes(".")) continue;
        pairs.push(key);
      }
      return pairs;
    }

    async function fetchTickerBatch(pairsChunk) {
      const url = "https://api.kraken.com/0/public/Ticker?pair=" + encodeURIComponent(pairsChunk.join(","));
      const r = await fetch(url);
      const j = await r.json();
      return j.result || {};
    }

    async function getTopPairsByVolumeUsd(allPairs, topN) {
      const batchSize = 20;
      const scores = [];

      for (let i = 0; i < allPairs.length; i += batchSize) {
        const chunk = allPairs.slice(i, i + batchSize);
        let tick = {};
        try { tick = await fetchTickerBatch(chunk); } catch { tick = {}; }

        for (const pairKey of chunk) {
          const t = tick[pairKey];
          if (!t) continue;
          const last = Number(t.c && t.c[0]) || 0;
          const vol24 = Number(t.v && t.v[1]) || 0;
          const volUsd = last * vol24;
          if (volUsd > 0) scores.push({ pair: pairKey, volUsd });
        }
      }

      scores.sort((a, b) => b.volUsd - a.volUsd);
      return scores.slice(0, topN).map(x => x.pair);
    }

    async function fetchOHLC(pair, intervalMin, candles) {
      const url = "https://api.kraken.com/0/public/OHLC?pair=" + encodeURIComponent(pair) + "&interval=" + intervalMin;
      const r = await fetch(url);
      const j = await r.json();

      const k = Object.keys(j.result || {}).find(x => x !== "last");
      const arr = (k && Array.isArray(j.result[k])) ? j.result[k] : [];

      return arr.slice(-(candles || 60)).map(x => ({
        time: Number(x[0]),
        open: Number(x[1]),
        high: Number(x[2]),
        low: Number(x[3]),
        close: Number(x[4]),
        volume: Number(x[6])
      }));
    }

    function decideStrategyOrder(res, currentPrice) {
      const h1 = res.h1 || [];
      const h4 = res.h4 || [];
      const m5 = res.m5 || [];

      const h1Closes = h1.map(x => x.close);
      const h4Closes = h4.map(x => x.close);
      const m5Closes = m5.map(x => x.close);

      if (h1Closes.length < 220 || h4Closes.length < 220 || m5Closes.length < 60) {
        return { quality: 0, tag: "Not enough data", side: null };
      }

      const ema200H1 = ema(h1Closes, 200);
      const ema200H4 = ema(h4Closes, 200);
      if (!Number.isFinite(ema200H1) || !Number.isFinite(ema200H4)) {
        return { quality: 0, tag: "EMA not ready", side: null };
      }

      const lastH1 = h1Closes[h1Closes.length - 1];
      const lastH4 = h4Closes[h4Closes.length - 1];

      const upBias = lastH1 > ema200H1 && lastH4 > ema200H4;
      const downBias = lastH1 < ema200H1 && lastH4 < ema200H4;

      const m5Ema20 = ema(m5Closes, 20);
      const m5Vwap = vwapFromCandles(m5);

      if (!Number.isFinite(m5Ema20) || !Number.isFinite(m5Vwap)) {
        return { quality: 0, tag: "M5 indicators missing", side: null };
      }

      const lastM5 = m5Closes[m5Closes.length - 1];
      const prevM5 = m5Closes[m5Closes.length - 2];

      const aboveEma = lastM5 > m5Ema20;
      const aboveVwap = lastM5 > m5Vwap;
      const reclaimLong = (prevM5 <= m5Ema20 || prevM5 <= m5Vwap) && (aboveEma && aboveVwap);

      const belowEma = lastM5 < m5Ema20;
      const belowVwap = lastM5 < m5Vwap;
      const reclaimShort = (prevM5 >= m5Ema20 || prevM5 >= m5Vwap) && (belowEma && belowVwap);

      if (!upBias && !downBias) return { quality: 0, tag: "Chop zone", side: null };

      if (upBias && reclaimLong) {
        const entry = currentPrice;
        const swingLow = approxPullbackSwingLow(m5Closes, 12);
        const stop = swingLow ? (swingLow * 0.999) : (entry * 0.992);
        const r = entry - stop;
        const tp = entry + (r * 2.0);

        return {
          quality: 85,
          tag: "Trend pullback reclaim",
          actionTitle: "Buy after pullback confirms",
          side: "buy",
          orderType: "limit",
          price: entry,
          stopLoss: stop,
          takeProfit: tp
        };
      }

      if (downBias && reclaimShort) {
        const entry = currentPrice;
        const swingHigh = approxPullbackSwingHigh(m5Closes, 12);
        const stop = swingHigh ? (swingHigh * 1.001) : (entry * 1.008);
        const r = stop - entry;
        const tp = entry - (r * 2.0);

        return {
          quality: 82,
          tag: "Trend pullback reclaim",
          actionTitle: "Sell after pullback confirms",
          side: "sell",
          orderType: "limit",
          price: entry,
          stopLoss: stop,
          takeProfit: tp
        };
      }

      return { quality: 0, tag: "No reclaim yet", side: null };
    }

    function openStrategy(pair) {
      const url = "/strategy.html?pair=" + encodeURIComponent(pair);
      window.open(url, "_blank", "noopener");
    }

    async function refreshHeader() {
      const bal = await getJson(apiUrl("/balance"));
      const usd = Number(bal.balance && bal.balance.ZUSD ? bal.balance.ZUSD : 0);
      document.getElementById("usdBal").textContent = usd.toFixed(4);
      document.getElementById("updated").textContent = new Date().toLocaleTimeString();
    }

    async function refreshStatus() {
      const box = document.getElementById("statusBox");

      let account = { krakenConnected: false, emailVerified: false };
      let mode = { simulator: false };

      try { account = await getJson(apiUrl("/api/account/status")); } catch {}
      try { mode = await getJson(apiUrl("/mode")); } catch {}

      box.innerHTML =
        "<div class='kvRow'><span class='muted'>Email verified</span><span class='" + (account.emailVerified ? "good" : "bad") + "' style='font-weight:bold;'>" + (account.emailVerified ? "Yes" : "No") + "</span></div>" +
        "<div class='kvRow'><span class='muted'>Kraken connected</span><span class='" + (account.krakenConnected ? "good" : "bad") + "' style='font-weight:bold;'>" + (account.krakenConnected ? "Yes" : "No") + "</span></div>" +
        "<div class='kvRow'><span class='muted'>Mode</span><span class='warn' style='font-weight:bold;'>" + (mode.simulator ? "Simulator" : "Live") + "</span></div>";
    }

    async function scanOnce() {
      const status = document.getElementById("scanStatus");
      const safeBody = document.getElementById("safeBody");

      const maxPairs = Math.max(5, Math.min(200, Number(document.getElementById("maxPairs").value || 30)));
      const minQuality = Math.max(0, Math.min(100, Number(document.getElementById("minQuality").value || 80)));
      const topSend = Math.max(1, Math.min(50, Number(document.getElementById("topSend").value || 10)));

      safeBody.innerHTML = "";
      status.textContent = "Loading pairs and market data...";

      const allPairs = await getAllUsdPairs();
      const topPairs = await getTopPairsByVolumeUsd(allPairs, maxPairs);

      const results = [];
      let done = 0;

      for (const p of topPairs) {
        done += 1;
        status.textContent = "Scanning " + done + " of " + topPairs.length + "  " + prettyPair(p);

        try {
          const [h1, h4, m5] = await Promise.all([
            fetchOHLC(p, 60, 260),
            fetchOHLC(p, 240, 260),
            fetchOHLC(p, 5, 120)
          ]);

          const last = m5.length ? m5[m5.length - 1].close : (h1.length ? h1[h1.length - 1].close : 0);
          const rowObj = { pair: p, h1, h4, m5, last };
          rowObj.recommended = decideStrategyOrder(rowObj, last);

          if (rowObj.recommended && Number(rowObj.recommended.quality || 0) >= minQuality) {
            results.push(rowObj);
          }
        } catch {
        }
      }

      results.sort((a, b) => Number(b.recommended.quality || 0) - Number(a.recommended.quality || 0));
      const toShow = results.slice(0, topSend);

      if (!toShow.length) {
        status.textContent = "No actionable safe trades right now";
        return;
      }

      for (const t of toShow) {
        const rec = t.recommended || {};
        const tr = document.createElement("tr");
        tr.className = "clickable";

        tr.innerHTML =
          "<td>" + prettyPair(t.pair) + "</td>" +
          "<td class='" + (String(rec.side) === "buy" ? "good" : "bad") + "' style='font-weight:bold;'>" + String(rec.side || "").toUpperCase() + "</td>" +
          "<td class='warn' style='font-weight:bold;'>" + String(rec.quality || 0) + "</td>" +
          "<td>" + round6(rec.price ?? t.last ?? 0) + "</td>" +
          "<td>" + round6(rec.takeProfit ?? 0) + "</td>" +
          "<td>" + round6(rec.stopLoss ?? 0) + "</td>" +
          "<td class='muted'>" + String(rec.tag || "") + "</td>";

        tr.addEventListener("click", () => openStrategy(t.pair));
        safeBody.appendChild(tr);
      }

      status.textContent = "Scan complete. Click any row to open strategy.";

      try {
        await postJson("/api/alerts/safest", { safeTrades: toShow });
      } catch {
      }
    }

    document.getElementById("btnScan").addEventListener("click", async () => {
      try {
        await refreshHeader();
        await scanOnce();
      } catch (e) {
        document.getElementById("scanStatus").textContent = String(e.message || e);
      }
    });

    document.getElementById("btnAuto").addEventListener("click", async () => {
      autoOn = !autoOn;
      const btn = document.getElementById("btnAuto");
      btn.textContent = autoOn ? "Auto scan off" : "Auto scan on";

      if (autoTimer) {
        clearInterval(autoTimer);
        autoTimer = null;
      }

      if (autoOn) {
        autoTimer = setInterval(async () => {
          try {
            await refreshHeader();
            await scanOnce();
          } catch {
          }
        }, 5 * 60 * 1000);
      }
    });

    document.getElementById("btnLogout").addEventListener("click", async () => {
      try { await postJson("/api/logout", {}); } catch {}
      window.location.replace("/login.html");
    });

    (async function init() {
      await refreshStatus();
      await refreshHeader();
    })();
  </script>
</body>
</html>
